<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="v1.6.0 - Generated 2025-09-12">
<title>Cgreen : Unit Tests, Stubbing and Mocking for C and C++</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Cgreen : Unit Tests, Stubbing and Mocking for C and C++</h1>
<div class="details">
<span id="author" class="author">v1.6.0 - Generated 2025-09-12</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_cgreen_quickstart_guide">1. Cgreen Quickstart Guide</a>
<ul class="sectlevel2">
<li><a href="#_what_is_cgreen">1.1. What is Cgreen?</a></li>
<li><a href="#_cgreen_vanilla_or_chocolate">1.2. Cgreen - Vanilla or Chocolate?</a></li>
<li><a href="#_installing_cgreen">1.3. Installing Cgreen</a></li>
<li><a href="#tdd_with_cgreen">1.4. Five Minutes Doing TDD with Cgreen</a></li>
<li><a href="#_what_are_mock_functions">1.5. What are Mock Functions?</a></li>
</ul>
</li>
<li><a href="#_building_cgreen_test_suites">2. Building Cgreen test suites</a>
<ul class="sectlevel2">
<li><a href="#_writing_basic_tests">2.1. Writing Basic Tests</a></li>
<li><a href="#_the_standard_constraints">2.2. The Standard Constraints</a></li>
<li><a href="#_asserting_c_exceptions">2.3. Asserting C++ Exceptions</a></li>
<li><a href="#_bdd_style_vs_tdd_style">2.4. BDD Style vs. TDD Style</a></li>
<li><a href="#_a_runner">2.5. A Runner</a></li>
<li><a href="#_beforeeach_and_aftereach">2.6. BeforeEach and AfterEach</a></li>
<li><a href="#_each_test_in_its_own_process">2.7. Each Test in its Own Process</a></li>
<li><a href="#debugging">2.8. Debugging <strong>Cgreen</strong> tests</a></li>
<li><a href="#_building_composite_test_suites">2.9. Building Composite Test Suites</a></li>
</ul>
</li>
<li><a href="#_mocking_functions_with_cgreen">3. Mocking functions with Cgreen</a>
<ul class="sectlevel2">
<li><a href="#_the_problem_with_streams">3.1. The Problem with Streams</a></li>
<li><a href="#_record_and_playback">3.2. Record and Playback</a></li>
<li><a href="#_setting_expectations_on_mock_functions">3.3. Setting Expectations on Mock Functions</a></li>
<li><a href="#_running_tests_with_mocked_functions">3.4. Running Tests With Mocked Functions</a></li>
<li><a href="#_mocks_are">3.5. Mocks Are&#8230;&#8203;</a></li>
</ul>
</li>
<li><a href="#_more_on_expect_and_mock">4. More on <code>expect()</code> and <code>mock()</code></a>
<ul class="sectlevel2">
<li><a href="#_important_things_to_remember_about_expect_and_mock">4.1. Important Things To Remember About <code>expect()</code> and <code>mock()</code></a></li>
<li><a href="#refactoring-tests">4.2. Refactoring Tests with Mocks - CAUTION!</a></li>
<li><a href="#_other_use_cases_for_mocks">4.3. Other Use Cases For Mocks</a></li>
<li><a href="#_the_mock_macros">4.4. The Mock Macros</a></li>
<li><a href="#_combining_expectations">4.5. Combining Expectations</a></li>
<li><a href="#_order_of_constraints">4.6. Order of constraints</a></li>
<li><a href="#_order_of_multiple_expects">4.7. Order of multiple `expect`s</a></li>
<li><a href="#_handling_out_parameters">4.8. Handling out-parameters</a></li>
<li><a href="#_returning_struct">4.9. Returning <code>struct</code></a></li>
<li><a href="#_mocking_struct_parameters">4.10. Mocking <code>struct</code> Parameters</a></li>
<li><a href="#_capturing_parameters">4.11. Capturing Parameters</a></li>
</ul>
</li>
<li><a href="#_special_cases">5. Special Cases</a>
<ul class="sectlevel2">
<li><a href="#_working_with_doubles">5.1. Working with <code>doubles</code></a></li>
<li><a href="#_using_cgreen_with_c">5.2. Using Cgreen with C++</a></li>
</ul>
</li>
<li><a href="#_context_system_under_test_suites">6. Context, System Under Test &amp; Suites</a>
<ul class="sectlevel2">
<li><a href="#_the_sut_system_under_test">6.1. The SUT - System Under Test</a></li>
<li><a href="#_contexts_and_before_and_after">6.2. Contexts and Before and After</a></li>
</ul>
</li>
<li><a href="#auto-discovery">7. Automatic Test Discovery</a>
<ul class="sectlevel2">
<li><a href="#_forgot_to_add_your_test">7.1. Forgot to Add Your Test?</a></li>
<li><a href="#_the_solution_the_cgreen_runner">7.2. The Solution - the 'cgreen-runner'</a></li>
<li><a href="#runner">7.3. Using the Runner</a></li>
<li><a href="#runner-options">7.4. Cgreen Runner Options</a></li>
<li><a href="#_selecting_tests_to_run">7.5. Selecting Tests To Run</a></li>
<li><a href="#_multiple_test_libraries">7.6. Multiple Test Libraries</a></li>
<li><a href="#_setup_teardown_and_custom_reporters">7.7. Setup, Teardown and Custom Reporters</a></li>
<li><a href="#xensure">7.8. Skipping Tests</a></li>
</ul>
</li>
<li><a href="#changing_style">8. Changing Style</a></li>
<li><a href="#reporter">9. Changing Cgreen Reporting</a>
<ul class="sectlevel2">
<li><a href="#_replacing_the_reporter">9.1. Replacing the Reporter</a></li>
<li><a href="#builtin_reporters">9.2. Built-in Reporters</a></li>
<li><a href="#_rolling_our_own">9.3. Rolling Our Own</a></li>
<li><a href="#_the_testreporter_structure">9.4. The TestReporter Structure</a></li>
<li><a href="#_an_example_xml_reporter">9.5. An Example XML Reporter</a></li>
</ul>
</li>
<li><a href="#_advanced_usage">10. Advanced Usage</a>
<ul class="sectlevel2">
<li><a href="#_custom_constraints">10.1. Custom Constraints</a></li>
</ul>
</li>
<li><a href="#_hints_and_tips">11. Hints and Tips</a>
<ul class="sectlevel2">
<li><a href="#cgreen-mocker">11.1. <code>cgreen-mocker</code> - Automated Mocking</a></li>
<li><a href="#_compiler_error_messages">11.2. Compiler Error Messages</a></li>
<li><a href="#_signed_unsigned_hex_and_byte">11.3. Signed, Unsigned, Hex and Byte</a></li>
<li><a href="#_cgreen_and_coverage">11.4. Cgreen and Coverage</a></li>
<li><a href="#_garbled_output">11.5. Garbled Output</a></li>
</ul>
</li>
<li><a href="#_legacy_style_assertions">Appendix A: Legacy Style Assertions</a></li>
<li><a href="#_release_history">Appendix B: Release History</a>
<ul class="sectlevel2">
<li><a href="#_1_6_0">B.1. 1.6.0</a></li>
<li><a href="#_1_5_1">B.2. 1.5.1</a></li>
<li><a href="#_1_5_0">B.3. 1.5.0</a></li>
<li><a href="#_1_4_0">B.4. 1.4.0</a></li>
<li><a href="#_1_3_0">B.5. 1.3.0</a></li>
<li><a href="#_1_2_0">B.6. 1.2.0</a></li>
<li><a href="#_1_1_0">B.7. 1.1.0</a></li>
<li><a href="#_1_0_0">B.8. 1.0.0</a></li>
</ul>
</li>
<li><a href="#_license">Appendix C: License</a></li>
<li><a href="#_acknowledgements">Appendix D: Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_cgreen_quickstart_guide">1. Cgreen Quickstart Guide</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_is_cgreen">1.1. What is Cgreen?</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> is a unit testing framework for the C and C++ software developer, a test automation and software quality assurance tool for programmers and development teams.
The tool is completely open source published under the <a href="https://github.com/cgreen-devs/cgreen/blob/master/LICENSE">ISC, OpenBSD, license</a>.</p>
</div>
<div class="paragraph">
<p>Unit testing is a development practice popularised by the agile development community.
It is characterised by writing many small tests alongside the normal code.
Often the tests are written before the code they are testing, in a tight test-code-refactor loop.
Done this way, the practice is known as Test Driven Development.
 <strong>Cgreen</strong> was designed specifically to support this style of development.</p>
</div>
<div class="paragraph">
<p>Unit tests are written in the same language as the code, in our case C or C++.
This avoids the mental overhead of constantly switching language, and also allows you to use any application code in your tests.</p>
</div>
<div class="paragraph">
<p>Here are some of its features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fluent API resulting in very readable tests</p>
</li>
<li>
<p>Expressive and clear output using the default reporter</p>
</li>
<li>
<p>Fully functional mocks, both strict, loose and learning</p>
</li>
<li>
<p>Mocks with side effects</p>
</li>
<li>
<p>Each test runs in its own process for test suite robustness</p>
</li>
<li>
<p>Automatic discovery and running of tests using dynamic library inspection</p>
</li>
<li>
<p>Extensive and expressive constraints for many datatypes</p>
</li>
<li>
<p>Custom constraints can be constructed by user</p>
</li>
<li>
<p>BDD-flavoured test declarations with Before and After declarations</p>
</li>
<li>
<p>Extensible reporting mechanism</p>
</li>
<li>
<p>Fully composable test suites</p>
</li>
<li>
<p>A single test can be run in a single process for easier debugging</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> also supports the classic xUnit-style assertions for easy porting from other frameworks.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> was initially developed to support C programming, but there is also support for C++.
It was initially a spinoff from a research project at Wordtracker and created by Marcus Baker.
Significant additions by Matt Hargett and continuous nurturing by Thomas Nilefalk has made <strong>Cgreen</strong> what it is today.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cgreen_vanilla_or_chocolate">1.2. Cgreen - Vanilla or Chocolate?</h3>
<div class="paragraph">
<p>Test driven development (TDD) really catched on when the JUnit framework for Java spread to other langauges, giving us a family of <a href="https://en.wikipedia.org/wiki/XUnit">xUnit</a> tools.
<strong>Cgreen</strong> was born in this wave and have many similarities to the xUnit family.</p>
</div>
<div class="paragraph">
<p>But TDD evolved over time and modern thinking and practice is more along the lines of BDD, an acronym for Behaviour Driven Development, made popular by people like Dan North and frameworks like JBehave, RSpec, Cucumber and Jasmine.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> follows this trend and has evolved to embrace a BDD-flavoured style of testing.
Although the fundamental mechanisms in TDD and 'technical' BDD are much the same, the shift in focus by changing wording from 'tests' to 'behaviour specifications' is very significant.</p>
</div>
<div class="paragraph">
<p>This document will present <strong>Cgreen</strong> using the more modern and better BDD-inspired style.
In a later section you can have a peek at the classic xUnit-family TDD API, but you should consider that as outdated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_installing_cgreen">1.3. Installing Cgreen</h3>
<div class="paragraph">
<p>There are two ways to install <strong>Cgreen</strong> in your system.</p>
</div>
<div class="sect3">
<h4 id="_installing_a_package">1.3.1. Installing a package</h4>
<div class="paragraph">
<p>The first way is to use packages provided by the <strong>Cgreen</strong> Team and porters for the various operating systems.
If your system uses a package manager ('apt', 'yum', 'brew' and so on) there might be a prebuilt package that you can just install using your systems package manager.</p>
</div>
<div class="paragraph">
<p>If no <strong>Cgreen</strong> package is distributed for your system you can download a package from <a href="https://github.com/cgreen-devs/cgreen/releases">Cgreen GitHub project</a>.
Install it using the normal procedures for your system.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At this point there are pre-built packages available for quite a few environments.
They are not all using the latest version, though.
If you need that, you can still build from source.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_installing_from_source">1.3.2. Installing from source</h4>
<div class="paragraph">
<p>A second way is available for developers and advanced users.
Basically this consists of fetching the sources of the project on <a href="https://github.com/cgreen-devs/cgreen">GitHub</a>, just click on "Download ZIP", and then compile them.
To do this you need the <a href="http://www.cmake.org">CMake</a> build system.</p>
</div>
<div class="paragraph">
<p>Once you have the CMake tool installed, the steps are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ unzip cgreen-master.zip
$ cd cgreen-master
$ make
$ make test
$ make install</pre>
</div>
</div>
<div class="paragraph">
<p>The initial <code>make</code> command will configure the build process and create a separate <code>build</code> directory before going there and building using <strong>CMake</strong>.
This is called an 'out of source build'.
It compiles <strong>Cgreen</strong> from outside the sources directory.
This helps the overall file organization and enables multi-target builds from the same sources by leaving the complete source tree untouched.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Experienced users may tweak the build configuration by going to the build subdirectory and use <code>ccmake ..</code> to modify the build configuration in that subtree.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Makefile is just there for convenience, it creates the build directory and invokes <strong>CMake</strong> there, so that you don&#8217;t have to.
This means that experienced <strong>CMake</strong> users can just do as they normally do with a <strong>CMake</strong>-based project instead of invoking <code>make</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The build process will create a library (on unix called <code>libcgreen.so</code>) which can be used in conjunction with the <code>cgreen.h</code> header file to compile and link your test code.
The created library is installed in the system directories, by default in <code>/usr/local/lib/</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_your_first_test">1.3.3. Your First Test</h4>
<div class="paragraph">
<p>We will start demonstrating the use of <strong>Cgreen</strong> by writing some tests for <strong>Cgreen</strong> itself to confirm that everything is working as it should.
Let&#8217;s start with a simple test module with no tests, called <code>first_test.c</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

Describe(Cgreen);
BeforeEach(Cgreen) {}
AfterEach(Cgreen) {}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is very unexciting.
It just creates an empty test suite and runs it.
It&#8217;s usually easier to proceed in small steps, and this is the smallest one I could think of.
The only complication is the <code>cgreen.h</code> header file and the mysterious looking "declarations" at the beginning of the file.</p>
</div>
<div class="paragraph">
<p>The BDD flavoured <strong>Cgreen</strong> notation calls for a System Under Test
(SUT), or a 'context'.
The declarations give a context to the tests and it also makes it more natural to talk about which module or class, the system under test, is actually responsible for the functionality we are describing.
In one way we are 'describing', or spec&#8217;ing, the functionality of the SUT.
That&#8217;s what the <code>Describe();</code> does.
And for technical reasons (actually requirements of the C language), you must declare the <code>BeforeEach()</code> and <code>AfterEach()</code> functions even if they are empty.
(You will get strange errors if you don&#8217;t!)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We are using the name "Cgreen" as the SUT in these first examples, as <strong>Cgreen</strong> itself is the object or class we want to test or describe.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I am assuming you have the <strong>Cgreen</strong> folder in the include search path to ensure compilation works, otherwise you&#8217;ll need to add that in the compilation command.</p>
</div>
<div class="paragraph">
<p>Then, building this test is, of course, trivial&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c first_test.c
$ gcc first_test.o -lcgreen -o first_test
$ ./first_test</pre>
</div>
</div>
<div class="paragraph">
<p>Invoking the executable should give&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (0 tests)...
Completed "main": No assertions.</pre>
</div>
</div>
<div class="paragraph">
<p>All of the above rather assumes you are working in a Unix like environment, probably with 'gcc'.
The code is pretty much standard C99, so any C compiler should work.
<strong>Cgreen</strong> should compile on all systems that support the <code>sys/msg.h</code> messaging library.
It has been tested on Linux, MacOSX, Cygwin.
If you are on Windows we would be glad if you could figure out how to build there.</p>
</div>
<div class="paragraph">
<p>So far we have tried compilation, and shown that the test suite actually runs.
Let&#8217;s add a meaningless test or two so that you can see how it runs&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

Describe(Cgreen);
BeforeEach(Cgreen) {}
AfterEach(Cgreen) {}

Ensure(Cgreen, passes_this_test) {
    assert_that(1 == 1);
}

Ensure(Cgreen, fails_this_test) {
    assert_that(0 == 1);
}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Cgreen, passes_this_test);
    add_test_with_context(suite, Cgreen, fails_this_test);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A test is denoted by the macro <code>Ensure</code> which takes an optional context (<code>Cgreen</code>) and a, hopefully descriptive, testname (<code>passes_this_test</code>).
You add the test to your suite using <code>add_test_with_context()</code>.</p>
</div>
<div class="paragraph">
<p>On compiling and running, we now get the output&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
first_tests.c:12: Failure: fails_this_test 
	Expected [0 == 1] to [be true]

  "main": 1 pass, 1 failure in 42ms.
Completed "main": 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TextReporter</code>, created by the call to <code>create_text_reporter()</code>, is the easiest way to output the test results.
It prints the failures as intelligent and expressive text messages on your console.</p>
</div>
<div class="paragraph">
<p>Of course "0" would never equal "1", but this shows that <strong>Cgreen</strong> presents the value you expect (<code>[be true]</code>) <em>and</em> the expression that you want to assert (<code>[0 == 1]</code>).
We can also see a handy short form for asserting boolean expressions (<code>assert_that(0 == 1);</code>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tdd_with_cgreen">1.4. Five Minutes Doing TDD with Cgreen</h3>
<div class="paragraph">
<p>For a more realistic example we need something to test.
We&#8217;ll pretend that we are writing a function to split the words of a sentence in place.
It would do this by replacing any spaces with string terminators and returns the number of conversions plus one.
Here is an example of what we have in mind&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *sentence = strdup("Just the first test");
word_count = split_words(sentence);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable <code>sentence</code> should now point at "Just\0the\0first\0test".
Not an obviously useful function, but we&#8217;ll be using it for something more practical later.</p>
</div>
<div class="paragraph">
<p>This time around we&#8217;ll add a little more structure to our tests.
Rather than having the test as a stand alone program, we&#8217;ll separate the runner from the test cases.
That way, multiple test suites of test cases can be included in the <code>main()</code> runner file.
This makes it less work to add more tests later.</p>
</div>
<div class="paragraph">
<p>Here is the, so far empty, test case in <code>words_test.c</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;

#include "words.h"
#include &lt;string.h&gt;

Describe(Words);
BeforeEach(Words) {}
AfterEach(Words) {}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the <code>all_tests.c</code> test runner&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

TestSuite *words_tests();

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_suite(suite, words_tests());
    if (argc &gt; 1) {
        return run_single_test(suite, argv[1], create_text_reporter());
    }
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> has two ways of running tests.
The default is to run all tests in their own protected processes.
This is what happens if you invoke <code>run_test_suite()</code>.
All tests are then completely independent since they run in separate processes, preventing a single run-away test from bringing the whole program down with it.
It also ensures that one test cannot leave any state to the next, thus forcing you to setup the prerequisites for each test correctly and clearly.</p>
</div>
<div class="paragraph">
<p>Building this scaffolding&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c words_test.c
$ gcc -c all_tests.c
$ gcc words_test.o all_tests.o -lcgreen -o all_tests</pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and executing the result gives the familiar&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (0 tests)...
  "words_tests": No assertions.
Completed "main": No assertions.</pre>
</div>
</div>
<div class="paragraph">
<p>Note that we get an extra level of output here, we have both <code>main</code> and <code>words_tests</code>.
That&#8217;s because <code>all_tests.c</code> adds the words test suite to its own (named <code>main</code> since it was created in the function <code>main()</code>).
All this scaffolding is pure overhead, but from now on adding tests will be a lot easier.</p>
</div>
<div class="paragraph">
<p>Here is a first test for <code>split_words()</code> in <code>words_test.c</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

#include "words.h"
#include &lt;string.h&gt;

Describe(Words);
BeforeEach(Words) {}
AfterEach(Words) {}

Ensure(Words, returns_word_count) {
    char *sentence = strdup("Birds of a feather");
    int word_count = split_words(sentence);
    assert_that(word_count, is_equal_to(4));
    free(sentence);
}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Words, returns_word_count);
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>assert_that()</code> macro takes two parameters, the value to assert and a constraint.
The constraints comes in various forms.
In this case we use the probably most common, <code>is_equal_to()</code>.
With the default <code>TextReporter</code> the message is sent to <code>STDOUT</code>.</p>
</div>
<div class="paragraph">
<p>To get this to compile we need to create the <code>words.h</code> header file&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int split_words(char *sentence);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and to get the code to link we need a stub function in <code>words.c</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int split_words(char *sentence) {
    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A full build later&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c all_tests.c
$ gcc -c words_test.c
$ gcc -c words.c
$ gcc all_tests.o words_test.o words.o -lcgreen -o all_tests
$ ./all_tests</pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and we get the more useful response&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (1 test)...
words_tests.c:13: Failure: words_tests -&gt; returns_word_count 
	Expected [word_count] to [equal] [4]
		actual value:			[0]
		expected value:			[4]

  "words_tests": 1 failure in 42ms.
Completed "main": 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>The breadcrumb trail following the "Failure" text is the nesting of the tests.
It goes from the test suites, which can be nested in each other, through the test function, and finally to the message from the assertion.
In the language of <strong>Cgreen</strong>, a "failure" is a mismatched assertion, or constraint, and an "exception" occurs when a test fails to complete for any reason, e.g. a segmentation fault.</p>
</div>
<div class="paragraph">
<p>We could get this to pass just by returning the value 4.
Doing TDD in really small steps, you would actually do this, but we&#8217;re not teaching TDD here.
Instead we&#8217;ll go straight to the core of the implementation&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;string.h&gt;

int split_words(char *sentence) {
  int i, count = 1;
  for (i = 0; i &lt; strlen(sentence); i++) {
    if (sentence[i] == ' ') {
      count++;
    }
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running it gives&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (1 test)...
  "words_tests": 1 pass in 42ms.
Completed "main": 1 pass in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>There is actually a hidden problem here, but our tests still passed so we&#8217;ll pretend we didn&#8217;t notice.</p>
</div>
<div class="paragraph">
<p>So it&#8217;s time to add another test.
We want to confirm that the string is broken into separate words&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...
Ensure(Words, returns_word_count) {
    ...
}

Ensure(Words, converts_spaces_to_zeroes) {
    char *sentence = strdup("Birds of a feather");
    split_words(sentence);
    int comparison = memcmp("Birds\0of\0a\0feather", sentence, strlen(sentence));
    assert_that(comparison, is_equal_to(0));
    free(sentence); 
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sure enough, we get a failure&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
words_tests.c:21: Failure: words_tests -&gt; converts_spaces_to_zeroes 
	Expected [comparison] to [equal] [0]
		actual value:			[-32]
		expected value:			[0]

  "words_tests": 1 pass, 1 failure in 42ms.
Completed "main": 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Not surprising given that we haven&#8217;t written the code yet.</p>
</div>
<div class="paragraph">
<p>The fix&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;string.h&gt;

int split_words(char *sentence) {
  int i, count = 1;
  for (i = 0; i &lt; strlen(sentence); i++) {
    if (sentence[i] == ' ') {
      sentence[i] = '\0';
      count++;
    }
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;reveals our previous hack&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
words_tests.c:13: Failure: words_tests -&gt; returns_word_count 
	Expected [word_count] to [equal] [4]
		actual value:			[2]
		expected value:			[4]

  "words_tests": 1 pass, 1 failure in 42ms.
Completed "main": 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Our earlier test now fails, because we have affected the <code>strlen()</code> call in our loop.
Moving the length calculation out of the loop&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int split_words(char *sentence) {
  int i, count = 1, length = strlen(sentence);
  for (i = 0; i &lt; length; i++) {
    ...
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;restores order&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
  "words_tests": 2 passes in 42ms.
Completed "main": 2 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s nice to keep the code under control while we are actually writing it, rather than debugging later when things are more complicated.</p>
</div>
<div class="paragraph">
<p>That was pretty straight forward.
Let&#8217;s do something more interesting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_are_mock_functions">1.5. What are Mock Functions?</h3>
<div class="paragraph">
<p>The next example is a more realistic extension of our previous attempts.
As in real life we first implement something basic and then we go for the functionality that we need.
In this case a function that invokes a callback for each word found in a sentence.
Something like&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void act_on_word(const char *word, void *memo) { ... }
words("This is a sentence", &amp;act_on_word, &amp;memo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the <code>memo</code> pointer is just some accumulated data that the <code>act_on_word()</code> callback might work with.
Other people will write the <code>act_on_word()</code> function and probably many other functions like it.
The callback is actually a flex point, and not of interest right now.</p>
</div>
<div class="paragraph">
<p>The function under test is the <code>words()</code> function and we want to make sure it walks the sentence correctly, dispatching individual words as it goes.
So what calls are made are very important.
How do we go about to test this?</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a one word sentence.
In this case we would expect the callback to be invoked once with the only word, right?
Here is the test for that&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;
...
void mocked_callback(const char *word, void *memo) {
    mock(word, memo);
}

Ensure(Words, invokes_callback_once_for_single_word_sentence) {
    expect(mocked_callback,
           when(word, is_equal_to_string("Word")), when(memo, is_null));
    words("Word", &amp;mocked_callback, NULL);
}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    ...
    add_test_with_context(suite, Words, invokes_callback_once_for_single_word_sentence);
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the funny looking <code>mock()</code> function?</p>
</div>
<div class="paragraph">
<p>A mock is basically a programmable object.
In C objects are limited to functions, so this is a mock function.
The macro <code>mock()</code> compares the incoming parameters with any expected values and dispatches messages to the test suite if there is a mismatch.
It also returns any values that have been preprogrammed in the test.</p>
</div>
<div class="paragraph">
<p>The test is <code>invokes_callback_once_for_single_word_sentence()</code>.
It programs the mock function using the <code>expect()</code> macro.
It expects a single call, and that single call should use the parameters <code>"Word"</code> and <code>NULL</code>.
If they don&#8217;t match, we will get a test failure.</p>
</div>
<div class="paragraph">
<p>So when the code under test (our <code>words()</code> function) calls the injected <code>mocked_callback()</code> it in turn will call <code>mock()</code> with the actual parameters.</p>
</div>
<div class="paragraph">
<p>Of course, we don&#8217;t add the mock callback to the test suite, it&#8217;s not a test.</p>
</div>
<div class="paragraph">
<p>For a successful compile and link, the <code>words.h</code> file must now look like&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int split_words(char *sentence);
void words(const char *sentence, void (*callback)(const char *, void *), void *memo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the <code>words.c</code> file should have the stub&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void words(const char *sentence, void (*callback)(const char *, void *), void *memo) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This gives us the expected failing test&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (3 tests)...
words_tests.c:32: Failure: words_tests -&gt; invokes_callback_once_for_single_word_sentence 
	Expected call was not made to mocked function [mocked_callback]

  "words_tests": 2 passes, 1 failure in 42ms.
Completed "main": 2 passes, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> reports that the callback was never invoked.
We can easily get the test to pass by filling out the implementation with&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void words(const char *sentence, void (*callback)(const char *, void *), void *memo) {
  (*callback)(sentence, memo);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, we just invoke it once with the whole string.
This is a temporary measure to get us moving.
For now everything should pass, although it doesn&#8217;t drive much functionality yet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (3 tests)...
  "words_tests": 4 passes in 42ms.
Completed "main": 4 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>That was all pretty conventional, but let&#8217;s tackle the trickier case of actually splitting the sentence.
Here is the test function we will add to <code>words_test.c</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Words, invokes_callback_for_each_word_in_a_phrase) {
    expect(mocked_callback, when(word, is_equal_to_string("Birds")));
    expect(mocked_callback, when(word, is_equal_to_string("of")));
    expect(mocked_callback, when(word, is_equal_to_string("a")));
    expect(mocked_callback, when(word, is_equal_to_string("feather")));
    words("Birds of a feather", &amp;mocked_callback, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each call is expected in sequence.
Any failures, or left-over or extra calls, and we get failures.
We can see all this when we run the tests&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (4 tests)...
words_tests.c:38: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase 
	Expected [[word] parameter in [mocked_callback]] to [equal string] ["Birds"]
		actual value:			["Birds of a feather"]
		expected to equal:		["Birds"]

words_tests.c:39: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase 
	Expected call was not made to mocked function [mocked_callback]

words_tests.c:40: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase 
	Expected call was not made to mocked function [mocked_callback]

words_tests.c:41: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase 
	Expected call was not made to mocked function [mocked_callback]

  "words_tests": 4 passes, 4 failures in 42ms.
Completed "main": 4 passes, 4 failures in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>The first failure tells the story.
Our little <code>words()</code> function called the mock callback with the entire sentence.
This makes sense, because that was the hack we did to get to the next test.</p>
</div>
<div class="paragraph">
<p>Although not relevant to this guide, I cannot resist getting these tests to pass.
Besides, we get to use the function we created earlier&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void words(const char *sentence, void (*callback)(const char *, void *), void *memo) {
  char *words = strdup(sentence);
  int word_count = split_words(words);
  char *word = words;
  while (word_count-- &gt; 0) {
    (*callback)(word, memo);
    word = word + strlen(word) + 1;
  }
  free(words);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And with some work we are rewarded with&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (4 tests)...
  "words_tests": 8 passes in 42ms.
Completed "main": 8 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>More work than I like to admit as it took me three goes to get this right.
I firstly forgot the <code>+ 1</code> added on to <code>strlen()</code>, then forgot to swap <code>sentence</code> for <code>word</code> in the <code>(*callback)()</code> call, and finally third time lucky.
Of course running the tests each time made these mistakes very obvious.
It&#8217;s taken me far longer to write these paragraphs than it has to write the code.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_cgreen_test_suites">2. Building Cgreen test suites</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Cgreen</strong> is a tool for building unit tests in the C or C++ languages.
These are usually written alongside the production code by the programmer to prevent bugs.
Even though the test suites are created by software developers, they are intended to be human readable C code, as part of their function is an executable specification.
Used in this way, the test harness delivers constant quality assurance.</p>
</div>
<div class="paragraph">
<p>In other words you&#8217;ll get less bugs.</p>
</div>
<div class="sect2">
<h3 id="_writing_basic_tests">2.1. Writing Basic Tests</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> tests are like C, or C++, functions with no parameters and no return value.
To signal that they actually are tests we mark them with the <code>Ensure</code> macro.
Here&#8217;s an example&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Strlen, returns_five_for_hello) {
    assert_that(strlen("Hello"), is_equal_to(5));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Ensure</code> macro takes two arguments (in the BDD style) where the first is the System Under Test (SUT) which must be declared with the <code>Describe</code> macro.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Describe(Strlen);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second argument is the test name and can be anything you want as long as it fullfills the rules for an identifier in C and C++.
A typical way to choose the named of the tests is what we see here, reading the declaration of the test makes sense since it is almost plain english, "Ensure strlen returns five for 'hello'".
No problem understanding what we aim to test, or in TDD lingo, test drive.
And it can be viewed as an example from a description of what strlen should be able to do.
In a way, extracting all the <code>Ensure</code>:s from your test might give you all the documentation you&#8217;ll need.</p>
</div>
<div class="paragraph">
<p>The call to <code>assert_that()</code> is the primary part of an assertion, which is complemented with a constraint, in this case
<code>is_equal_to()</code>, as a parameter.
This makes a very fluent interface to the asserts, that actually reads like English.
The general format is then</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">assert_that(actual, &lt;constraint&gt;);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sometimes you just want to fail the test explicitly, and there is a function for that too, <code>fail_test(const char *message)</code>.
And there is a function to explicitly pass, <code>pass_test(void)</code>.
There is also a function to programmatically skip a test, <code>skip_test(void)</code> to complement the <code>xEnsure</code> notation (see <a href="#xensure">Skipping Tests</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Assertions send messages to <strong>Cgreen</strong>, which in turn outputs the results.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_standard_constraints">2.2. The Standard Constraints</h3>
<div class="paragraph">
<p>Here are the standard constraints&#8230;&#8203;</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Constraint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Passes if actual value/expression&#8230;&#8203;</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Basic</em></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluates to true, buy you can also just leave out the constraint,
              e.g. <code>assert_that(found)</code> if <code>found</code> is of boolean type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluates to false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equals null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_non_null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">is a non null value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">d:o</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Integer compatible</em></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'== value'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_hex(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'== value', but will show values in HEX</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'!= value'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'&gt; value'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'&lt; value'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Structs and general data</em></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_contents_of(pointer, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches the data pointed
                                             to by <code>pointer</code> to a size
                                             of <code>size</code> bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_contents_of(pointer, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not match the data
                                                 pointed to by <code>pointer</code>
                                                 to a size of <code>size</code> bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Strings</em></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are equal when compared using <code>strcmp()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are not equal when compared using <code>strcmp()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contains_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">contains <code>value</code> when evaluated using <code>strstr()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_not_contain_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not contain <code>value</code> when evaluated
                                     using <code>strstr()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>begins_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">starts with the string <code>value</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_not_begin_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not start with the string <code>value</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ends_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ends with the string <code>value</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_not_end_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not end with the string <code>value</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Double floats</em></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are equal to <code>value</code> within the number of
                                significant digits (which you can set with a call
                                to <code>significant_figures_for_assert_double_are(int figures)</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are not equal to <code>value</code> within the number of
                                    significant digits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt; value</code> withing the number of significant digits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt; value</code> within the number of significant digits</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The boolean assertion macros accept an <code>int</code> value.
The equality assertions accept anything that can be cast to <code>intptr_t</code> and simply perform an <code>==</code> operation.
The string comparisons are slightly different in that they use the <code>&lt;string.h&gt;</code> library function <code>strcmp()</code>.
If you use <code>is_equal_to()</code> with <code>char *</code> pointers then it is the value of the pointers themselves that has to be the same, i.e. the pointers have to point at the same string for the test to pass.</p>
</div>
<div class="paragraph">
<p>The constraints above should be used as the second argument to one of the assertion functions:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_that(expected, constraint)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if <code>expected</code> fullfulls <code>constraint</code>,
                                        to be used for all assertions except <code>double</code>
                                        type values</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_that_double(expected, constraint)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if <code>expected</code> fullfulls <code>constraint</code>,
                                               only to be used for assertions on <code>double</code>
                                               type values</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
You cannot use C/C++ string literal concatenation (like <code>"don&#8217;t" "use" "string" "concatenation"</code>) in the parameters to the constraints.
If you do, you will get weird error messages about missing arguments to the constraint macros.
This is caused by the macros using argument strings to produce nice failure messages.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_asserting_c_exceptions">2.3. Asserting C++ Exceptions</h3>
<div class="paragraph">
<p>When you use <strong>CGreen</strong> with C++ there is one extra assertion available:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_throws(exception, expression)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if evaluating <code>expression</code> throws <code>exception</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_bdd_style_vs_tdd_style">2.4. BDD Style vs. TDD Style</h3>
<div class="paragraph">
<p>So far we have encouraged the modern BDD style.
It has merits that we really want you to benefit from.
But you might come across <strong>Cgreen</strong> test in another style, more like the standard TDD style, which is more inline with previous thinking and might be more similar to other frameworks.</p>
</div>
<div class="paragraph">
<p>The only difference, in principle, is the use of the SUT or 'context'.
In the BDD style you have it, in the TDD style you don&#8217;t.</p>
</div>
<div class="listingblock">
<div class="title">BDD style:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Describe(Strlen);                                                 <i class="conum" data-value="1"></i><b>(1)</b>
BeforeEach(Strlen) {}                                             <i class="conum" data-value="2"></i><b>(2)</b>
AfterEach(Strlen) {}                                              <i class="conum" data-value="3"></i><b>(3)</b>

Ensure(Strlen, returns_five_for_hello) {                          <i class="conum" data-value="4"></i><b>(4)</b>
    assert_that(strlen("Hello"), is_equal_to(5));
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello); <i class="conum" data-value="5"></i><b>(5)</b>
    return suite;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Describe</code> macro must name the SUT</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>BeforeEach</code> function&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; and the <code>AfterEach</code> functions must exist and name the SUT</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The test need to name the SUT</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Adding to the test suite</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
You can only have tests for a single SUT in the same source file.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you use the older pure-TDD style you skip the <code>Describe</code> macro, the <code>BeforeEach</code> and <code>AfterEach</code> functions.
You don&#8217;t need a SUT in the <code>Ensure()</code> macro or when you add the test to the suite.</p>
</div>
<div class="listingblock">
<div class="title">TDD style:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">                                                               <i class="conum" data-value="1"></i><b>(1)</b>
Ensure(strlen_returns_five_for_hello) {                        <i class="conum" data-value="2"></i><b>(2)</b>
    assert_that(strlen("Hello"), is_equal_to(5));
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, strlen_returns_five_for_hello);            <i class="conum" data-value="3"></i><b>(3)</b>
    return suite;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No <code>Describe</code>, <code>BeforeEach()</code> or <code>AfterEach()</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No SUT/context in the <code>Ensure()</code> macro</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>No SUT/context in <code>add_test()</code> and you should use this function instead
of <code>..with_context()</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You might think of the TDD style as the BDD style with a default SUT or context.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_a_runner">2.5. A Runner</h3>
<div class="paragraph">
<p>The tests are only run by running a test suite in some form.
(But see also <a href="#runner">Using the Runner</a>.)
We can create and run one especially for this test like so&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case you have spotted that the reference to <code>returns_five_for_hello</code> should have an ampersand in front of it, <code>add_test_with_context()</code> is actually a macro.
The <code>&amp;</code> is added automatically.
Further more, the <code>Ensure()</code>-macro actually mangles the tests name, so it is not actually a function name.
(This might also make them a bit difficult to find in the debugger&#8230;&#8203;.)</p>
</div>
<div class="paragraph">
<p>To run the test suite, we call <code>run_test_suite()</code> on it.
So we can just write&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    return run_test_suite(our_tests(), create_text_reporter());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results of assertions are ultimately delivered as passes and failures to a collection of callbacks defined in a <code>TestReporter</code> structure.
There is a predefined <code>TestReporter</code> in <strong>Cgreen</strong> called the <code>TextReporter</code> that delivers messages in plain text like we have already seen.</p>
</div>
<div class="paragraph">
<p>The return value of <code>run_test_suite()</code> is a standard C library/Unix exit code that can be returned directly by the <code>main()</code> function.</p>
</div>
<div class="paragraph">
<p>The complete test code now looks like&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;string.h&gt;

Describe(Strlen);
BeforeEach(Strlen) {}
AfterEach(Strlen) {}

Ensure(Strlen, returns_five_for_hello) {
    assert_that(strlen("Hello"), is_equal_to(5));
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    return suite;
}

int main(int argc, char **argv) {
    return run_test_suite(our_tests(), create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compiling and running gives&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c strlen_test.c
$ gcc strlen_test.o -lcgreen -o strlen_test
$ ./strlen_test
Running "our_tests" (1 test)...
  "our_tests": 1 pass in 42ms.
Completed "our_tests": 1 pass in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>We can see that the outer test suite is called <code>our_tests</code> since it was in <code>our_tests()</code> we created the test suite.
There are no messages shown unless there are failures.
So, let&#8217;s break our test to see it&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Strlen, returns_five_for_hello) {
    assert_that(strlen("Hiya"), is_equal_to(5));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;we&#8217;ll get the helpful message&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "our_tests" (1 test)...
strlen_tests.c:9: Failure: returns_five_for_hello 
	Expected [strlen("Hiya")] to [equal] [5]
		actual value:			[4]
		expected value:			[5]

  "our_tests": 1 failure in 42ms.
Completed "our_tests": 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> starts every message with the location of the test failure so that the usual error message identifying tools (like Emacs&#8217;s <code>next-error</code>) will work out of the box.</p>
</div>
<div class="paragraph">
<p>Once we have a basic test scaffold up, it&#8217;s pretty easy to add more tests.
Adding a test of <code>strlen()</code> with an empty string for example&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...
Ensure(Strlen, returns_zero_for_empty_string) {
    assert_equal(strlen("\0"), 0);
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    add_test_with_context(suite, Strlen, returns_zero_for_empty_string);
    return suite;
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>And so on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_beforeeach_and_aftereach">2.6. BeforeEach and AfterEach</h3>
<div class="paragraph">
<p>It&#8217;s common for test suites to have a lot of duplicate code, especially when setting up similar tests.
Take this database code for example&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mysql.h&gt;
#include "person.h"

Describe(Person);
BeforeEach(Person) {}
AfterEach(Person) {}

static void create_schema() {
    MYSQL *connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
    mysql_query(connection, "create table people (name, varchar(255) unique)");
    mysql_close(connection);
}

static void drop_schema() {
    MYSQL *connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
    mysql_query(connection, "drop table people");
    mysql_close(connection);
}

Ensure(Person, can_add_person_to_database) {
    create_schema();
    Person *person = create_person();
    set_person_name(person, "Fred");
    save_person(person);
    Person *found = find_person_by_name("Fred");
    assert_that(get_person_name(found), is_equal_to_string("Fred"));
    drop_schema();
}

Ensure(Person, cannot_add_duplicate_person) {
    create_schema();
    Person *person = create_person();
    set_person_name(person, "Fred");
    assert_that(save_person(person), is_true);
    Person *duplicate = create_person();
    set_person_name(duplicate, "Fred");
    assert_that(save_person(duplicate), is_false);
    drop_schema();
}

TestSuite *person_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Person, can_add_person_to_database);
    add_test_with_context(suite, Person, cannot_add_duplicate_person);
    return suite;
}

int main(int argc, char **argv) {
    return run_test_suite(person_tests(), create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have already factored out the duplicate code into its own functions <code>create_schema()</code> and <code>drop_schema()</code>, so things are not so bad.
At least not yet.
But what happens when we get dozens of tests?
For a test subject as complicated as a database <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord</a>, having dozens of tests is very likely.</p>
</div>
<div class="paragraph">
<p>We can get <strong>Cgreen</strong> to do some of the work for us by calling these methods before and after each test in the test suite.</p>
</div>
<div class="paragraph">
<p>Here is the new version&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...
static void create_schema() {
    ...
}

static void drop_schema() {
    ...
}

Describe(Person);
BeforeEach(Person) { create_schema(); }
AfterEach(Person) { drop_schema(); }

Ensure(Person, can_add_person_to_database) {
    Person *person = create_person();
    set_person_name(person, "Fred");
    save_person(person);
    Person *found = find_person_by_name("Fred");
    assert_that(get_person_name(found), is_equal_to_string("Fred"));
}

Ensure(Person, cannot_add_duplicate_person) {
    Person *person = create_person();
    set_person_name(person, "Fred");
    assert_that(save_person(person), is_true);
    Person *duplicate = create_person();
    set_person_name(duplicate, "Fred");
    assert_that(save_person(duplicate), is_false);
}

TestSuite *person_tests() {
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this new arrangement <strong>Cgreen</strong> runs the <code>create_schema()</code> function before each test, and the <code>drop_schema()</code> function after each test.
This saves some repetitive typing and reduces the chance of accidents.
It also makes the tests more focused.</p>
</div>
<div class="paragraph">
<p>The reason we try so hard to strip everything out of the test functions is the fact that the test suite acts as documentation.
In our <code>person.h</code> example we can easily see that <code>Person</code> has some kind of name property, and that this value must be unique.
For the tests to act like a readable specification we have to remove as much mechanical clutter as we can.</p>
</div>
<div class="paragraph">
<p>In this particular case there are more lines that we could move from the tests to <code>BeforeEach()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    Person *person = create_person();
    set_person_name(person, "Fred");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course that would require an extra variable, and it might make the tests less clear.
And as we add more tests, it might turn out to not be common to all tests.
This is a typical judgement call that you often get to make with <code>BeforeEach()</code> and <code>AfterEach()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use the pure-TDD notation, not having the test subject named by the <code>Describe</code> macro, you can&#8217;t have the <code>BeforeEach()</code> and <code>AfterEach()</code> either.
In this case you can still run a function before and after every test.
Just nominate any <code>void(void)</code> function by calling the function <code>set_setup()</code> and/or <code>set_teardown()</code> with the suite and the function that you want to run before/after each test.
In the example above that would be <code>set_setup(suite, create_schema);</code> and <code>set_teardown(suite, drop_schema);</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A couple of details.
There is only one <code>BeforeEach()</code> and one <code>AfterEach()</code> allowed in each <code>TestSuite</code>.
Also, the <code>AfterEach()</code> function might not be run if the test crashes, causing some test interference.
This brings us nicely onto the next section&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="_each_test_in_its_own_process">2.7. Each Test in its Own Process</h3>
<div class="paragraph">
<p>Consider this test method&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(CrashExample, seg_faults_for_null_dereference) {
    int *p = NULL;
    (*p)++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Crashes are not something you would normally want to have in a test run.
Not least because it will stop you receiving the very test output you need to tackle the problem.</p>
</div>
<div class="paragraph">
<p>To prevent segmentation faults and other problems bringing down the test suites, <strong>Cgreen</strong> runs every test in its own process.</p>
</div>
<div class="paragraph">
<p>Just before calling the <code>BeforeEach()</code> (or <code>setup</code>) function, <strong>Cgreen</strong> <code>fork()</code>:s.
The main process waits for the test to complete normally or die.
This includes calling the <code>AfterEach()</code>(or <code>teardown</code>) function, if any.
If the test process dies, an exception is reported and the main test process carries on with the next test.</p>
</div>
<div class="paragraph">
<p>For example&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;stdlib.h&gt;

Describe(CrashExample);
BeforeEach(CrashExample) {}
AfterEach(CrashExample) {}

Ensure(CrashExample, seg_faults_for_null_dereference) {
    int *p = NULL;
    (*p)++;
}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, CrashExample, seg_faults_for_null_dereference);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When built and run, this gives&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (1 test)...
crash_tests.c:8: Exception: seg_faults_for_null_dereference 
	Test terminated with signal: Segmentation fault

  "main": 1 exception in 42ms.
Completed "main": 1 exception in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>The normal thing to do in this situation is to fire up the debugger.
Unfortunately, the constant <code>fork()</code>:ing of <strong>Cgreen</strong> can be one extra complication too many when debugging.
It&#8217;s enough of a problem to find the bug.</p>
</div>
<div class="paragraph">
<p>To get around this, and also to allow the running of one test at a time, <strong>Cgreen</strong> has the <code>run_single_test()</code> function.
The signatures of the two run methods are&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int run_test_suite(TestSuite *suite, TestReporter *reporter);</code></p>
</li>
<li>
<p><code>int run_single_test(TestSuite *suite, char *test, TestReporter *reporter);</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The extra parameter of <code>run_single_test()</code>, the <code>test</code> string, is the name of the test to select.
This could be any test, even in nested test suites (see below).
Here is how we would use it to debug our crashing test&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, CrashExample, seg_faults_for_null_dereference);
    return run_single_test(suite, "seg_faults_for_null_dereference", create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When run in this way, <strong>Cgreen</strong> will not <code>fork()</code>.
But see the section on  <a href="#debugging">Debugging <strong>Cgreen</strong> tests</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The function <code>run()</code> is a good place to place a breakpoint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is a typical session:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gdb crash2
...
(gdb) break main
(gdb) run
...
(gdb) break run
(gdb) continue
...
Running "main" (1 tests)...

Breakpoint 2, run_the_test_code (suite=suite@entry=0x2003abb0,
    spec=spec@entry=0x402020 &lt;CgreenSpec__CrashExample__seg_faults_for_null_dereference__&gt;,
    reporter=reporter@entry=0x2003abe0) at /cygdrive/c/Users/Thomas/Utveckling/Cgreen/cgreen/src/runner.c:270
270         run(spec);
(gdb) step
run (spec=0x402020 &lt;CgreenSpec__CrashExample__seg_faults_for_null_dereference__&gt;)
    at /cygdrive/c/Users/Thomas/Utveckling/Cgreen/cgreen/src/runner.c:217
217             spec-&gt;run();
(gdb) step
CrashExample__seg_faults_for_null_dereference () at crash_test2.c:9
9           int *p = NULL;
(gdb) step
10          (*p)++;
(gdb) step

Program received signal SIGSEGV, Segmentation fault.
0x004011ea in CrashExample__seg_faults_for_null_dereference () at crash_test2.c:10
10          (*p)++;</pre>
</div>
</div>
<div class="paragraph">
<p>Which shows exactly where the problem is.</p>
</div>
<div class="paragraph">
<p>This deals with the case where your code throws an exception like segmentation fault, but what about a process that fails to complete by getting stuck in a loop?</p>
</div>
<div class="paragraph">
<p>Well, <strong>Cgreen</strong> will wait forever too.
But, using the C signal handlers, we can place a time limit on the process by sending it an interrupt.
To save us writing this ourselves, <strong>Cgreen</strong> includes the <code>die_in()</code> function to help us out.</p>
</div>
<div class="paragraph">
<p>Here is an example of time limiting a test&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...
Ensure(CrashExample, seg_faults_for_null_dereference) {
    ...
}

Ensure(CrashExample, will_loop_forever) {
    die_in(1);
    while(0 == 0) { }
}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, CrashExample, seg_faults_for_null_dereference);
    add_test_with_context(suite, CrashExample, will_loop_forever);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When executed, the code will slow for a second, and then finish with&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
crash_tests.c:8: Exception: seg_faults_for_null_dereference 
	Test terminated with signal: Segmentation fault

crash_tests.c:13: Exception: will_loop_forever 
	Test terminated unexpectedly, likely from a non-standard exception or Posix signal

  "main": 2 exceptions in 42ms.
Completed "main": 2 exceptions in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Note that you see the test results as they come in.
<strong>Cgreen</strong> streams the results as they happen, making it easier to figure out where the test suite has problems.</p>
</div>
<div class="paragraph">
<p>Of course, if you want to set a general time limit on all your tests, then you can add a <code>die_in()</code> to a <code>BeforeEach()</code> (or <code>setup()</code>) function.
<strong>Cgreen</strong> will then apply the limit to each of the tests in that context, of course.</p>
</div>
<div class="paragraph">
<p>Another possibility is the use of an environment variable named <code>CGREEN_TIMEOUT_PER_TEST</code> which, if set to a number will apply that timeout to every test run.
This will apply to all tests in the same run.</p>
</div>
</div>
<div class="sect2">
<h3 id="debugging">2.8. Debugging <strong>Cgreen</strong> tests</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> protects itself from being torn down by an exception in a test by <code>fork()</code>-ing each test into a separate process.
A catastrophic error will then only affect the child process for that specific test and <strong>Cgreen</strong> can catch it, rather than crashing too.
It can then report the exception and continue with the next test.</p>
</div>
<div class="sect3">
<h4 id="_no_fork_please">2.8.1. No fork, please</h4>
<div class="paragraph">
<p>If you want to debug any of your tests the constant <code>fork()</code>-ing might make that difficult or impossible.
There are also other circumstances that might require that you don&#8217;t use <code>fork()</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to make <strong>Cgreen</strong> refrain from <code>fork()</code>-ing.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> does not <code>fork()</code> when only a single test is run by name with the function <code>run_single_test()</code>.
To debug you can then obviously set a breakpoint at that test (but note that its actual name probably have been mangled).
<strong>Cgreen</strong> does some book-keeping before actually getting to the test, so a function easier to find might be the one simply called <code>run()</code>.</p>
</div>
<div class="paragraph">
<p>The second way is to define the environment variable <code>CGREEN_NO_FORK</code>.
If <strong>Cgreen</strong> can get that variable from the environment using <code>getenv()</code> it will run the test(s) in the same process.
In this case the non-forking applies to <strong>all</strong> tests run, so all test will run in the same process, namely *Cgreen*s main process.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This might bring your whole test suite down if a single test causes an exception.
So it is not a recommended setting for normal use.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_debugging_with_cgreen_runner">2.8.2. Debugging with <code>cgreen-runner</code></h4>
<div class="paragraph">
<p>If you use the convenient auto-discovery feature of <strong>Cgreen</strong> (see
<a href="#auto-discovery">Automatic Test Discovery</a>) by running dynamic loadable libraries through
<code>cgreen-runner</code>, it might be tricky to figure out to where to put
breaks and to get them to "take".</p>
</div>
<div class="paragraph">
<p><code>cgreen-runner</code> obviously loads the library (or libraries) with your
tests dynamically so the tests are not available before executing the
code that loads them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The function <code>run()</code> is a good place to place a breakpoint.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_cgreen_debug">2.8.3. <code>cgreen-debug</code></h4>
<div class="paragraph">
<p>For some platforms a utility script, <code>cgreen-debug</code>, is installed when you install <strong>Cgreen</strong>.
It makes it very convenient to start a debugging session for a particular test.</p>
</div>
<div class="paragraph">
<p>Find out the logical name of the test, which is composed of the Context and the Testname, in the form &lt;context&gt;:&lt;testname&gt;.
Then just invoke <code>cgreen-debug</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-debug &lt;library&gt; &lt;context&gt;:&lt;testname&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The script will try to find a debugger, invoke it on the
<code>cgreen-runner</code> and break on that test.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently it only supports <code>gdb</code> and will prefer <code>cgdb</code> if
that&#8217;s available.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_building_composite_test_suites">2.9. Building Composite Test Suites</h3>
<div class="paragraph">
<p>The <code>TestSuite</code> is a composite structure.
This means test suites can be added to test suites, building a tree structure that will be executed in order.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s combine the <code>strlen()</code> tests with the <code>Person</code> tests above.
Firstly we need to remove the <code>main()</code> functions.
E.g&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Strlen, returns_five_for_hello) {
   ...
}

Ensure(Strlen, returns_zero_for_empty_string) {
   ...
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    add_test_with_context(suite, Strlen, returns_zero_for_empty_string);
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can write a small runner with a new <code>main()</code> function&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

TestSuite *our_tests();
TestSuite *person_tests();

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_suite(suite, our_tests());
    add_suite(suite, person_tests());
    if (argc &gt; 1) {
        return run_single_test(suite, argv[1], create_text_reporter());
    }
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s usually easier to place the <code>TestSuite</code> prototypes directly in the runner source, rather than have lot&#8217;s of header files.
This is the same reasoning that let us drop the prototypes for the test functions in the actual test scripts.
We can get away with this, because the tests are more about documentation than encapsulation.</p>
</div>
<div class="paragraph">
<p>As we saw above, we can run a single test using the <code>run_single_test()</code> function, and we&#8217;d like to be able to do that from the command line.
So we added a simple <code>if</code> block to take the test name as an optional argument.
The entire test suite will be searched for the named test.
This trick also saves us a recompile when we debug.</p>
</div>
<div class="paragraph">
<p>When you use the BDD notation you can only have a single test subject (which is actually equivalent of a suite) in a single file because you can only have one <code>Describe()</code> macro in each file.
But using this strategy you can create composite suites that takes all your tests and run them in one go.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Rewrite pending.
The next couple of sections does not reflect the current best thinking.
They are remnants of the TDD notation.
Using BDD notation you would create separate contexts, each in its own file, with separate names, for each of the fixture cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use the TDD (non-BDD) notation you can build several test suites in the same file, even nesting them.
We can even add mixtures of test functions and test suites to the same parent test suite.
Loops will give trouble, however.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If we do place several suites in the same file, then all the suites will be named the same in the breadcrumb trail in the test message.
They will all be named after the function the create call sits in.
If you want to get around this, or you just like to name your test suites, you can use <code>create_named_test_suite()</code> instead of <code>create_test_suite()</code>.
This takes a single string parameter.
In fact <code>create_test_suite()</code> is just a macro that inserts the <code><em>func</em></code> constant into <code>create_named_test_suite()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What happens to <code>setup</code> and <code>teardown</code> functions in a <code>TestSuite</code> that contains other <code>TestSuite</code>:s?</p>
</div>
<div class="paragraph">
<p>Well firstly, <strong>Cgreen</strong> does not <code>fork()</code> when running a suite.
It leaves it up to the child suite to <code>fork()</code> the individual tests.
This means that a <code>setup</code> and <code>teardown</code> will run in the main process.
They will be run once for each child suite.</p>
</div>
<div class="paragraph">
<p>We can use this to speed up our <code>Person</code> tests above.
Remember we were creating a new connection and closing it again in the fixtures.
This means opening and closing a lot of connections.
At the slight risk of some test interference, we could reuse the connection accross tests&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...
static MYSQL *connection;

static void create_schema() {
    mysql_query(connection, "create table people (name, varchar(255) unique)");
}

static void drop_schema() {
    mysql_query(connection, "drop table people");
}

Ensure(can_add_person_to_database) { ... }
Ensure(cannot_add_duplicate_person) { ... }

void open_connection() {
    connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
}

void close_connection() {
    mysql_close(connection);
}

TestSuite *person_tests() {
    TestSuite *suite = create_test_suite();
    set_setup(suite, create_schema);
    set_teardown(suite, drop_schema);
    add_test(suite, can_add_person_to_database);
    add_test(suite, cannot_add_duplicate_person);

    TestSuite *fixture = create_named_test_suite("Mysql fixture");
    add_suite(fixture, suite);
    set_setup(fixture, open_connection);
    set_teardown(fixture, close_connection);
    return fixture;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The trick here is creating a test suite as a wrapper whose sole purpose is to wrap the main test suite in the fixture.
This is our 'fixture' pointer.
This code is a little confusing, because we have two sets of fixtures in the same test script.</p>
</div>
<div class="paragraph">
<p>We have the MySQL connection fixture.
This will run <code>open_connection()</code> and <code>close_connection()</code> just once at the beginning and end of the person tests.
This is because the <code>suite</code> pointer is the only member of <code>fixture</code>.</p>
</div>
<div class="paragraph">
<p>We also have the schema fixture, the <code>create_schema()</code> and <code>drop_schema()</code>, which is run before and after every test.
Those are still attached to the inner <code>suite</code>.</p>
</div>
<div class="paragraph">
<p>In the real world we would probably place the connection fixture in its own file&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static MYSQL *connection;

MYSQL *get_connection() {
    return connection;
}

static void open_connection() {
    connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
}

static void close_connection() {
    mysql_close(connection);
}

TestSuite *connection_fixture(TestSuite *suite) {
    TestSuite *fixture = create_named_test_suite("Mysql fixture");
    add_suite(fixture, suite);
    set_setup(fixture, open_connection);
    set_teardown(fixture, close_connection);
    return fixture;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows the reuse of common fixtures across projects.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mocking_functions_with_cgreen">3. Mocking functions with Cgreen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When testing you want certainty above all else.
Random events destroy confidence in your test suite and force needless extra runs "to be sure".
A good test places the system under test into a tightly controlled environment.
A test chamber if you like.
This makes the tests fast, repeatable and reliable.</p>
</div>
<div class="paragraph">
<p>To create a test chamber for testing code, we have to control any outgoing calls from the code under test.
We won&#8217;t believe our test failure if our code is making calls to the internet for example.
The internet can fail all by itself.
Not only do we not have total control, but it also means we have to get dependent components working before we can test the higher level code.
This makes it difficult to code top down.</p>
</div>
<div class="paragraph">
<p>The solution to this dilemma is to write stub code for the components whilst the higher level code is written.
This pollutes the code base with temporary code, and the test isolation disappears when the system is eventually fleshed out.</p>
</div>
<div class="paragraph">
<p>The ideal is to have minimal stubs written for each individual test.
<strong>Cgreen</strong> encourages this approach by making such tests easier to write.</p>
</div>
<div class="sect2">
<h3 id="_the_problem_with_streams">3.1. The Problem with Streams</h3>
<div class="paragraph">
<p>How would we test the following code&#8230;&#8203;?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length] = ch) == '\n') {
            break;
        }
        buffer[length + 1] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a fairly generic stream filter that turns the incoming characters into C string paragraphs.
Each call creates one paragraph, returning a pointer to it or returning <code>NULL</code> if there is no paragraph.
The paragraph has memory allocated to it and the stream is advanced ready for the next call.
That&#8217;s quite a bit of functionality, and there are plenty of nasty boundary conditions.
I really want this code tested before I deploy it.</p>
</div>
<div class="paragraph">
<p>The problem is the stream dependency.
We could use a real stream, but that will cause all sorts of headaches.
It makes the test of our paragraph formatter dependent on a working stream.
It means we have to write the stream first, bottom up coding rather than top down.
It means we will have to simulate stream failures - not easy.
It will also mean setting up external resources.
This is more work, will run slower, and could lead to spurious test failures.</p>
</div>
<div class="paragraph">
<p>By contrast, we could write a simulation of the stream for each test, called a "server stub".</p>
</div>
<div class="paragraph">
<p>For example, when the stream is empty nothing should happen.
We hopefully get <code>NULL</code> from <code>read_paragraph</code> when the stream is exhausted.
That is, it just returns a steady stream of `EOF`s.</p>
</div>
<div class="paragraph">
<p>Fortunately, this function takes the stream as a parameter.
This is called dependency injection and is a very important concept.
Thanks to this we can write a small function, a stub, with the same signature, that simulates a real stream, and inject that instead of a real stream, which the production code probably does.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the code does not inject the dependency this way we can often compile the stub separately and link with that instead the real stream.
In this case your stub will have to have the same name as the original function, of course.
(This is sometimes called the linkage seam.)
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int empty_stream(void *stream) {
    return EOF;
}

Describe(ParagraphReader);
BeforeEach(ParagraphReader) {}
AfterEach(ParagraphReader) {}

Ensure(ParagraphReader, gives_null_when_reading_empty_stream) {
    assert_that(read_paragraph(&amp;empty_stream, NULL), is_null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our simulation is easy here, because our fake stream returns only one value.
Things are harder when the function result changes from call to call as a real stream would.
Simulating this would mean messing around with static variables and counters that are reset for each test.
And of course, we will be writing quite a few stubs.
Often a different one for each test.
That&#8217;s a lot of clutter.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> can handle this clutter for us by letting us write a single programmable function for all our tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_record_and_playback">3.2. Record and Playback</h3>
<div class="paragraph">
<p>We can redo our example by creating a <code>stream_stub()</code> function.
We can call it anything we want, and since I thought we wanted to have a stubbed stream&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int stream_stub(void *stream) {
    return (int)mock(stream);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hardly longer that our trivial server stub above, it is just a macro to generate a return value, but we can reuse this in test after test.
Let&#8217;s see how.</p>
</div>
<div class="paragraph">
<p>For our simple example above we just tell it to always return <code>EOF</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;

char *read_paragraph(int (*read)(void *), void *stream);

static int stream_stub(void *stream) {
    return (int)mock(stream);
}

Describe(ParagraphReader);
BeforeEach(ParagraphReader) {}
AfterEach(ParagraphReader) {}

Ensure(ParagraphReader, gives_null_when_reading_empty_stream) {
    always_expect(stream_stub, will_return(EOF));                                 <i class="conum" data-value="1"></i><b>(1)</b>
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_null);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>always_expect()</code> macro takes the function name as an argument and also defines the return value using the call to <code>will_return()</code>.
This is a declaration of an expectation of a call to the stub, and we have told our <code>stream_stub()</code> to always return <code>EOF</code>  when called.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s see if our production code actually works&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (1 test)...
  "ParagraphReader": 1 pass in 42ms.
Completed "stream": 1 pass in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>So far, so good.
On to the next test.</p>
</div>
<div class="paragraph">
<p>If we want to test a one character line, we have to send the terminating <code>EOF</code> or <code>"\n"</code> as well as the single character.
Otherwise our code will loop forever, giving an infinite line of that character.</p>
</div>
<div class="paragraph">
<p>Here is how we can do this&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(ParagraphReader, gives_one_character_line_for_one_character_stream) {
    expect(stream_stub, will_return('a'));
    expect(stream_stub, will_return(EOF));
    char *line = read_paragraph(&amp;stream_stub, NULL);
    assert_that(line, is_equal_to_string("a"));
    free(line);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the <code>always_expect()</code> instruction, <code>expect()</code> sets up an expectation of a single call and specifying <code>will_return()</code> sets the single return value for just that call.
It acts like a record and playback model.
Successive expectations map out the return sequence that will be given back once the test proper starts.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll add this test to the suite and run it&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (2 tests)...
stream_tests.c:23: Failure: ParagraphReader -&gt; gives_one_character_line_for_one_character_stream 
	Expected [line] to [equal string] ["a"]
		actual value:			[""]
		expected to equal:		["a"]

  "ParagraphReader": 1 pass, 1 failure in 42ms.
Completed "stream": 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Oops.
Our code under test doesn&#8217;t work.
Already we need a fix&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length - 1] = ch) == '\n') {              <i class="conum" data-value="1"></i><b>(1)</b>
            break;
        }
        buffer[length] = '\0';                                <i class="conum" data-value="2"></i><b>(2)</b>
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After moving the indexing here&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and here&#8230;&#8203;</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>around a bit everything is fine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (2 tests)...
  "ParagraphReader": 2 passes in 42ms.
Completed "stream": 2 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>So, how do the <strong>Cgreen</strong> stubs work?
Each <code>expect()</code> describes one call to the stub and when a call to <code>will_return()</code> is included, the return values will be collected and returned in order as the expected calls arrive.</p>
</div>
<div class="paragraph">
<p>The <code>mock()</code> macro captures the parameter names, their values and the <code><em>func</em></code> property (the name of the stub function).
<strong>Cgreen</strong> can then use these to look up entries in the return list, and also to generate more helpful messages.</p>
</div>
<div class="paragraph">
<p>We can now crank out our tests quite quickly&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(ParagraphReader, gives_one_word_line_for_one_word_stream) {
    expect(stream_stub, will_return('t'));
    expect(stream_stub, will_return('h'));
    expect(stream_stub, will_return('e'));
    always_expect(stream_stub, will_return(EOF));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string("the"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;ve been a bit naughty.
As each test runs in its own process, I haven&#8217;t bothered to free the pointers to the paragraphs.
I&#8217;ve just let the operating system do it.
Purists may want to add the extra clean up code.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve also used <code>always_expect()</code> for the last instruction.
Without this, if the stub is given an instruction it does not expect, it will throw a test failure.
This is overly restrictive, as our <code>read_paragraph()</code> function could quite legitimately call the stream after it had run off of the end.
OK, that would be odd behaviour, but that&#8217;s not what we are testing here.
If we were, it would be placed in a test of its own.
The <code>always_expect()</code> call tells <strong>Cgreen</strong> to keep going after the first three letters, allowing extra calls.</p>
</div>
<div class="paragraph">
<p>As we build more and more tests, they start to look like a specification of the wanted behaviour&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(ParagraphReader, drops_line_ending_from_word_and_stops) {
    expect(stream_stub, will_return('t'));
    expect(stream_stub, will_return('h'));
    expect(stream_stub, will_return('e'));
    expect(stream_stub, will_return('\n'));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string("the"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and just for luck&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(ParagraphReader, gives_empty_line_for_single_line_ending) {
    expect(stream_stub, will_return('\n'));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string(""));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we must not use <code>always_return()</code>.
We want to leave the stream where it is, ready for the next call to <code>read_paragraph()</code>.
If we call the stream beyond the line ending, we want to fail.</p>
</div>
<div class="paragraph">
<p>Oops, that was a little too fast.
Turns out we are failing anyway&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (5 tests)...
stream_tests.c:40: Failure: ParagraphReader -&gt; drops_line_ending_from_word_and_stops 
	Expected [read_paragraph(&amp;stream_stub, ((void *)0))] to [equal string] ["the"]
		actual value:			["the
"]
		expected to equal:		["the"]

stream_tests.c:45: Failure: ParagraphReader -&gt; gives_empty_line_for_single_line_ending 
	Expected [read_paragraph(&amp;stream_stub, ((void *)0))] to [equal string] [""]
		actual value:			["
"]
		expected to equal:		[""]

  "ParagraphReader": 3 passes, 2 failures in 42ms.
Completed "stream": 3 passes, 2 failures in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Clearly we are passing through the line ending.
Another fix later&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length - 1] = ch) == '\n') {
            buffer[--length] = '\0';
            break;
        }
        buffer[length] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we are passing again&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (5 tests)...
  "ParagraphReader": 5 passes in 42ms.
Completed "stream": 5 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>There are no limits to the number of stubbed methods within a test,
only that two stubs cannot have the same name.
The following will cause problems&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int stream_stub(void *stream) {
    return (int)mock(stream);
}

Ensure(Streams, bad_test) {
    expect(stream_stub, will_return('a'));
    do_stuff(&amp;stream_stub, &amp;stream_stub);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You <em>could</em> program the same stub to return values for the two streams, but that would make a very brittle test.
Since we&#8217;d be making it heavily dependent on the exact internal behaviour that we are trying to test, or test drive, it will break as soon as we change that implementation.
The test will also become very much harder to read and understand. And we really don&#8217;t want that.</p>
</div>
<div class="paragraph">
<p>So, it will be necessary to have two stubs to make this test behave, but that&#8217;s not a problem&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int first_stream_stub(void *stream) {
    return (int)mock(stream);
}

static int second_stream_stub(void *stream) {
    return (int)mock(stream);
}

Ensure(Streams, good_test) {
    expect(first_stream_stub, will_return('a'));
    expect(second_stream_stub, will_return('a'));
    do_stuff(&amp;first_stream_stub, &amp;second_stream_stub);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have a way of writing fast, clear tests with no external dependencies.
The information flow is still one way though, from stub to the code under test.
When our code calls complex procedures, we won&#8217;t want to pick apart the effects to infer what happened.
That&#8217;s too much like detective work.
And why should we? We just want to know that we dispatched the correct information down the line.</p>
</div>
<div class="paragraph">
<p>Things get more interesting when we think of the traffic going the other way, from code to stub.
This gets us into the same territory as mock objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_expectations_on_mock_functions">3.3. Setting Expectations on Mock Functions</h3>
<div class="paragraph">
<p>To swap the traffic flow, we&#8217;ll look at an outgoing example instead.
Here is the prewritten production code&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void by_paragraph(int (*read)(void *), void *in, void (*write)(void *, char *), void *out) {
    while (1) {
        char *line = read_paragraph(read, in);
        if ((line == NULL) || (strlen(line) == 0)) {
            return;
        }
        (*write)(out, line);
        free(line);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the start of a formatter utility.
Later filters will probably break the paragaphs up into justified text, but right now that is all abstracted behind the <code>void write(void *, char *)</code> interface.
Our current interests are: does it loop through the paragraphs, and does it crash?</p>
</div>
<div class="paragraph">
<p>We could test correct paragraph formation by writing a stub that collects the paragraphs into a <code>struct</code>.
We could then pick apart that <code>struct</code> and test each piece with assertions.
This approach is extremely clumsy in C.
The language is just not suited to building and tearing down complex edifices, never mind navigating them with assertions.
We would badly clutter our tests.</p>
</div>
<div class="paragraph">
<p>Instead we&#8217;ll test the output as soon as possible, right in the called function&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...
void expect_one_letter_paragraph(void *stream, char *paragraph) {
    assert_that(paragraph, is_equal_to_string("a"));
}

Ensure(Formatter, makes_one_letter_paragraph_from_one_character_input) {
    by_paragraph(
            &amp;one_character_stream,
            NULL,
            &amp;expect_one_letter_paragraph,
            NULL);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>By placing the assertions into the mocked function, we keep the tests minimal.
The catch with this method is that we are back to writing individual functions for each test.
We have the same problem as we had with hand coded stubs.</p>
</div>
<div class="paragraph">
<p>Again, <strong>Cgreen</strong> has a way to automate this.
Here is the rewritten test&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int reader(void *stream) {
    return (int)mock(stream);
}

static void writer(void *stream, char *paragraph) {
    mock(stream, paragraph);
}

Ensure(Formatter, makes_one_letter_paragraph_from_one_character_input) {
    expect(reader, will_return('a'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string("a")));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where are the assertions?</p>
</div>
<div class="paragraph">
<p>Unlike our earlier stub, <code>reader()</code> can now check its parameters.
In object oriented circles, an object that checks its parameters as well as simulating behaviour is called a mock object.
By analogy <code>reader()</code> is a mock function, or mock callback.</p>
</div>
<div class="paragraph">
<p>Using the <code>expect()</code> macro, we have set up the expectation that <code>writer()</code> will be called just once.
That call must have the string <code>"a"</code> for the <code>paragraph</code> parameter.
If the actual value of that parameter does not match, the mock function will issue a failure straight to the test suite.
This is what saves us writing a lot of assertions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_running_tests_with_mocked_functions">3.4. Running Tests With Mocked Functions</h3>
<div class="paragraph">
<p>It&#8217;s about time we actually ran our test&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (1 test)...
  "Formatter": 1 pass in 42ms.
Completed "formatter": 1 pass in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Confident that a single character works, we can further specify the behaviour.
Firstly an input sequence&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Formatter, makes_one_paragraph_if_no_line_endings) {
    expect(reader, will_return('a'));
    expect(reader, will_return(' '));
    expect(reader, will_return('b'));
    expect(reader, will_return(' '));
    expect(reader, will_return('c'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string("a b c")));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more intelligent programmer than me would place all these calls in a
loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (2 tests)...
  "Formatter": 2 passes in 42ms.
Completed "formatter": 2 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Next, checking an output sequence&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Formatter, generates_separate_paragraphs_for_line_endings) {
    expect(reader, will_return('a'));
    expect(reader, will_return('\n'));
    expect(reader, will_return('b'));
    expect(reader, will_return('\n'));
    expect(reader, will_return('c'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string("a")));
    expect(writer, when(paragraph, is_equal_to_string("b")));
    expect(writer, when(paragraph, is_equal_to_string("c")));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again we can se that the <code>expect()</code> calls follow a record and playback model.
Each one tests a successive call.
This sequence confirms that we get <code>"a"</code>, <code>"b"</code> and <code>"c"</code> in order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (3 tests)...
  "Formatter": 5 passes in 42ms.
Completed "formatter": 5 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>So, why the 5 passes?
Each <code>expect()</code> with a constrait is actually an assert.
It asserts that the call specified is actually made with the parameters given and in the specified order.
In this case all the expected calls were made.</p>
</div>
<div class="paragraph">
<p>Then we&#8217;ll make sure the correct stream pointers are passed to the correct functions.
This is a more realistic parameter check&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Formatter, pairs_the_functions_with_the_resources) {
    expect(reader, when(stream, is_equal_to(1)), will_return('a'));
    always_expect(reader, when(stream, is_equal_to(1)), will_return(EOF));
    expect(writer, when(stream, is_equal_to(2)));
    by_paragraph(&amp;reader, (void *)1, &amp;writer, (void *)2);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (4 tests)...
  "Formatter": 9 passes in 42ms.
Completed "formatter": 9 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>And finally we&#8217;ll specify that the writer is not called if
there is no paragraph.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Formatter, ignores_empty_paragraphs) {
    expect(reader, will_return('\n'));
    always_expect(reader, will_return(EOF));
    never_expect(writer);
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This last test is our undoing&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (5 tests)...
formatter_tests.c:59: Failure: Formatter -&gt; ignores_empty_paragraphs 
	Mocked function [writer] has an expectation that it will never be called, but it was

  "Formatter": 9 passes, 1 failure in 42ms.
Completed "formatter": 9 passes, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously blank lines are still being dispatched to the <code>writer()</code>.
Once this is pointed out, the fix is obvious&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void by_paragraph(int (*read)(void *), void *in, void (*write)(void *, char *), void *out) {
    while (1) {
        char *line = read_paragraph(read, in);
        if ((line == NULL) || (strlen(line) == 0)) {
            return;
        }
        (*write)(out, line);
        free(line);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tests with <code>never_expect()</code> can be very effective at uncovering subtle
bugs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (5 tests)...
  "Formatter": 10 passes in 42ms.
Completed "formatter": 10 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>All done.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mocks_are">3.5. Mocks Are&#8230;&#8203;</h3>
<div class="paragraph">
<p>Using mocks is a very handy way to isolate a unit by catching and
controlling calls to external units.
Depending on your style of coding two schools of thinking have emerged. And of course <strong>Cgreen</strong> supports both!</p>
</div>
<div class="sect3">
<h4 id="_strict_or_loose_mocks">3.5.1. Strict or Loose Mocks</h4>
<div class="paragraph">
<p>The two schools are thinking a bit differently about what mock expectations means.
Does it mean that all external calls must be declared and expected?
What happens if a call was made to a mock that wasn&#8217;t expected?
And vice versa, if an expected call was not made?</p>
</div>
<div class="paragraph">
<p>Actually, the thinking is not only a school of thought, you might want to switch from one to the other depending on the test.
So <strong>Cgreen</strong> allows for that too.</p>
</div>
<div class="paragraph">
<p>By default <strong>Cgreen</strong> mocks are 'strict', which means that a call to an non-expected mock will be considered a failure.
So will an expected call that was not fullfilled.
You might consider this a way to define a unit through all its exact behaviours towards its neighbours.</p>
</div>
<div class="paragraph">
<p>On the other hand, 'loose' mocks are looser.
They allow both unfulfilled expectations and try to handle unexpected calls in a reasonable way.</p>
</div>
<div class="paragraph">
<p>You can use both with in the same suite of tests using the call <code>cgreen_mocks_are(strict_mocks);</code> and <code>cgreen_mocks_are(loose_mocks);</code> respectively.
Typically you would place that call at the beginning of the test, or in a setup or <code>BeforeEach()</code> if it applies to all tests in a suite.</p>
</div>
</div>
<div class="sect3">
<h4 id="_learning_mocks">3.5.2. Learning Mocks</h4>
<div class="paragraph">
<p>Working with legacy code and trying to apply TDD, BDD, or even simply adding some unit tests, is not easy.
You&#8217;re working with unknown code that does unknown things with unknown counterparts.</p>
</div>
<div class="paragraph">
<p>So the first step would be to isolate the unit.
We won&#8217;t go into details on how to do that here, but basically you would replace the interface to other units with mocks.
This is a somewhat tedious manual labor, but will result in an isolated unit where you can start applying your unit tests.</p>
</div>
<div class="paragraph">
<p>Once you have your unit isolated in a harness of mocks, we need to figure out which calls it does to other units, now replaced by mocks, in the specific case we are trying to test.</p>
</div>
<div class="paragraph">
<p>This might be complicated, so <strong>Cgreen</strong> can make that a bit simpler.
There is a third 'mode' of the <strong>Cgreen</strong> mocks, the <em>learning mocks</em>.</p>
</div>
<div class="paragraph">
<p>If you temporarily add the call <code>cgreen_mocks_are(learning_mocks);</code> at the beginning of your unit test, the mocks will record all calls and present a list of those calls in order, including the actual parameter values, on the standard output.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s look at the following example from the <strong>Cgreen</strong> unit tests.
It&#8217;s a bit contorted since the test actually call the mocked functions directly, but I believe it will serve as an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int integer_out() {
    return (int)mock();
}

static char *string_out(int p1) {
    return (char *)mock(p1);
}

Ensure(LearningMocks, emit_pastable_code) {
    cgreen_mocks_are(learning_mocks);
    string_out(1);
    string_out(2);
    integer_out();
    integer_out();
    string_out(3);
    integer_out();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can see the call to <code>cgreen_mocks_are()</code> starting the test and
setting the mocks into learning mode.</p>
</div>
<div class="paragraph">
<p>If we run this, just as we usually run tests, the following will show
up in our terminal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "learning_mocks" (1 tests)...
LearningMocks -&gt; emit_pastable_code : Learned mocks are
        expect(string_out, when(p1, is_equal_to(1)));
        expect(string_out, when(p1, is_equal_to(2)));
        expect(integer_out);
        expect(integer_out);
        expect(string_out, when(p1, is_equal_to(3)));
        expect(integer_out);
Completed "LearningMocks": 0 passes, 0 failures, 0 exceptions.
Completed "learning_mocks": 0 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>If this was for real we could just copy this and paste it in place of
the call to <code>cgreen_mocks_are()</code> and we have all the expectations
done.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before you can do this you need to implement the mock functions, of course.
I.e. write functions that replaces the real functions and instead calls <code>mock()</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a test fails with an exception, you won&#8217;t get the learned calls unfortunately.
They are collected and printed at the end of the test.
This might be improved at some future time.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can try the <code>cgreen-mocker</code> for this, as described in <a href="#cgreen-mocker"><code>cgreen-mocker</code> - Automated Mocking</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_on_expect_and_mock">4. More on <code>expect()</code> and <code>mock()</code></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_important_things_to_remember_about_expect_and_mock">4.1. Important Things To Remember About <code>expect()</code> and <code>mock()</code></h3>
<div class="paragraph">
<p>Using <code>expect()</code> and <code>mock()</code> is a very powerful way to isolate your code under test from its dependencies.
But it is not always easy to follow what happens, and when.</p>
</div>
<div class="paragraph">
<p>Here are some important things to remember when working with <strong>Cgreen</strong> mocks.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>calls to <code>expect()</code> collects constraints and any other required information when it is called</p>
</li>
<li>
<p>this also goes for <code>will_return()</code> which will save the value of its parameter <em>when it is called</em></p>
</li>
<li>
<p>the actual evaluation and execution of those constraints occur when <code>mock()</code> is called in the function named in the <code>expect()</code> call(s)</p>
</li>
<li>
<p>calls to a function specified by the <code>expect()</code> calls are evaluated in the same order as the <code>expect()</code>s were executed, but only for that named function</p>
</li>
<li>
<p>the lexical scope of the first parameter in a <code>when()</code> is always inside the mocked function where the <code>mock()</code> call is made</p>
</li>
<li>
<p>the lexical scope of arguments to an <code>is_equal_to&#8230;&#8203;()</code> is where that call is made</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In summary, <code>expect()</code> does early collection, including evaluation of return value expression, and <code>mock()</code> does late evaluation of the constraints collected against the given arguments to <code>mock()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="refactoring-tests">4.2. Refactoring Tests with Mocks - CAUTION!</h3>
<div class="paragraph">
<p>After a while you are bound to get tests with calls to <code>expect()</code>.
You might even have common patterns in multiple tests.
So your urge to refactor starts to set in.
And that is good, go with it, we have tests to rely on.</p>
</div>
<div class="paragraph">
<p>But there are a lot of things going on behind the scenes when you use <strong>Cgreen</strong>, often with the help of some serious macro-magic, so special care needs to be taken when refactoring tests that have <code>expect()</code> in them.</p>
</div>
<div class="sect3">
<h4 id="_renaming">4.2.1. Renaming</h4>
<div class="paragraph">
<p>The first "gotcha" is when you rename a function that you mock.
You are likely to have `expect()`s for that function too.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
the function name in an <code>expect()</code> is "text" so it will not be catched by a refactoring tool.
You will need to change the name there manually.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_local_variables">4.2.2. Local Variables</h4>
<div class="paragraph">
<p>For example, consider this code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Readline, can_read_some_characters) {
    char canned_a = 'a';
    char canned_b = 'b';
    char canned_c = 'c';

    expect(mocked_read,
           will_set_contents_of_output_parameter(buf, &amp;canned_a, sizeof(char)),
           will_return(1));
    expect(mocked_read,
           will_set_contents_of_output_parameter(buf, &amp;canned_b, sizeof(char)),
           will_return(1));
    expect(mocked_read,
           will_set_contents_of_output_parameter(buf, &amp;canned_c, sizeof(char)),
           will_return(1));

    ...
    &lt;call something that calls mocked_read()&gt;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is very tempting to break out the common expect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void expect_char(char ch) {
    expect(mocked_read,
        will_set_contents_of_output_parameter(buf, &amp;ch, sizeof(char)),
        will_return(1));
}

Ensure(Readline, can_read_some_characters) {
    char canned_a = 'a';
    char canned_b = 'b';
    char canned_c = 'c';

    expect_char(canned_a);
    expect_char(canned_b);
    expect_char(canned_c);

    ...
    &lt;call something that calls mocked_read()&gt;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Much nicer, right?</p>
</div>
<div class="paragraph">
<p>This will most likely lead to a segmentation fault or illegal memory reference, something that can be really tricky to track down.
The problem is that when <code>mocked_read()</code> is actually called, as an effect of calling something that calls <code>mocked_read()</code>, the parameter <code>ch</code> to the nicely extracted <code>expect_char()</code> does not exist anymore.</p>
</div>
<div class="paragraph">
<p>Good thing that you run the tests after each and every little refactoring, right?
Because then you know that it was the extraction you just did that was the cause.
Then you can come here and read up on what the problem might be and what to do about it.</p>
</div>
<div class="paragraph">
<p>At first glance the fix might look easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void expect_char(char ch) {
    char saved_ch = ch;
    expect(mocked_read,
    will_set_contents_of_output_parameter(buf, &amp;saved_ch, sizeof(char)),
        will_return(1));
}

Ensure(Readline, can_read_some_characters) {
   ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Close! But the local variable is also gone at the call to <code>mocked_read()</code>. Of course.</p>
</div>
<div class="paragraph">
<p>Ok, so let&#8217;s make it static:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void expect_char(char ch) {
    static char saved_ch = ch;
    expect(mocked_read,
        will_set_contents_of_output_parameter(buf, &amp;saved_ch, sizeof(char)),
        will_return(1));
}

Ensure(Readline, can_read_some_characters) {
   ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ok, so then it must exist.
But the problem then becomes the three consequtive calls to <code>expect_char()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Readline, can_read_some_characters) {
    char canned_a = 'a';
    char canned_b = 'b';
    char canned_c = 'c';

    expect_char(canned_a);
    expect_char(canned_b);
    expect_char(canned_c);

    ...
    &lt;call something that calls mocked_read()&gt;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of those have a different actual parameter, which is hard to store in one variable.
Even if it is static.</p>
</div>
<div class="paragraph">
<p>The solution is now quite obvious:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void expect_char(char *ch_p) {
    expect(mocked_read,
        will_set_contents_of_output_parameter(buf, ch_p, sizeof(char)),
        will_return(1));
}

Ensure(Readline, can_read_some_characters) {
    char canned_a = 'a';
    char canned_b = 'b';
    char canned_c = 'c';

    expect_char(&amp;canned_a);
    expect_char(&amp;canned_b);
    expect_char(&amp;canned_c);

    ...
    &lt;call something that calls mocked_read()&gt;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using pointers to the variables in the test, we can ensure that the values are live when the expected call is made.
So we don&#8217;t have to make the character variables used in the test static, because as local variables those will remain live long enough.</p>
</div>
<div class="paragraph">
<p>And this is the moral here, you cannot use local variables in an extracted function as data for a mocked function call.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Variables that are to be sent to a mocked function MUST be live at the call to that mocked function.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other_use_cases_for_mocks">4.3. Other Use Cases For Mocks</h3>
<div class="sect3">
<h4 id="_out_parameters">4.3.1. Out Parameters</h4>
<div class="paragraph">
<p>In C all function parameters are by value so if a function needs to return a value through a parameter that has to be done using a pointer.
Typically this is a pointer to the area or variable the function should fill.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> provides <code>will_set_contents_of_output_parameter()</code> to handle this use case.
For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void convert_to_uppercase(char *converted_string, const char *original_string) {
    mock(converted_string, original_string);
}

Ensure(setting_content_of_out_parameter) {
    expect(convert_to_uppercase,
           when(original_string, is_equal_to_string("upper case")),
           will_set_contents_of_output_parameter(converted_string,
                                          "UPPER CASE", 11));
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the mock for <code>convert_to_uppercase()</code> is called it will write the string "UPPER CASE" in the area pointed to by <code>converted_string</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_setting_fields">4.3.2. Setting fields</h4>
<div class="paragraph">
<p>Sometimes you need to set a field in a struct sent by reference to a mocked function.
You cannot use the <code>will_set_contents_of_output_parameter()</code> directly since you can&#8217;t, or even don&#8217;t want to, know the complete information in the structure.
But with a little bit of boilerplate in your mock function you can still write to a single field.</p>
</div>
<div class="paragraph">
<p>In the mock function you need to create a local variable that points to the field you want to update.
You can then use this pointer variable in the mock call to supplement the real parameters.</p>
</div>
<div class="paragraph">
<p>This local variable will then be accessible in <code>expect()</code> calls as if it was a parameter, and you can use it to wrote data to where it points, which then should be the field in the incoming structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct structure {
    int field;
    char *string;
};

void update_field(struct structure *struct_to_update) {
    int *field = &amp;struct_to_update-&gt;field;
    mock(struct_to_update, field);
}

Ensure(setting_field_of_parameter) {
    int fourty_two = 42;
    expect(update_field,
           will_set_contents_of_output_parameter(field, &amp;fourty_two, sizeof(int)));
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The local variable <code>field</code> in the mock function is set to point to the field that we need to update.
It is then exposed by including it in the <code>mock()</code> call, and <code>will_set_contents_of_output_parameter()</code> will use it to update whatever it points to with the data provided in the <code>expect()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Both the local variable and the data argument in the call to <code>will_set_contents_of_output_parameter()</code> must be pointers.
You cannot use literals as data, except when it is a string literal which as per C convention is converted to a pointer.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_side_effects">4.3.3. Side Effects</h4>
<div class="paragraph">
<p>Sometimes returning simple values is not enough.
The function that you want to mock might have some side effect, like setting a global error code, or aggregate some data.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that the <code>reader</code> increments a counter every time it gets called and we need to mimic that behaviour.
There are many ways to do this, but here is one using the side effect feature.
It works by calling a callback function that you provide, allowing you to feed some data to it.</p>
</div>
<div class="paragraph">
<p>We create the "side effect function" which needs to take a single argument which should be a pointer to the "side effect data".
You will have to cast that datapointer to the correct type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void update_counter(void * counter) {
    *(int*)counter = *(int*)counter + 1;
}

Ensure(using_side_effect) {
    int number_of_times_reader_was_called = 0;
    expect(reader, will_return('\n'));
    always_expect(reader,
                  will_return(EOF),
                  with_side_effect(&amp;update_counter,
                                  &amp;number_of_times_reader_was_called));
    never_expect(writer);
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);

    assert_that(number_of_times_reader_was_called, is_equal_to(1));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_mock_macros">4.4. The Mock Macros</h3>
<div class="paragraph">
<p>When specifying behavior of mocks there are three parts.
First, how often the specified behaviour or expectation will be executed:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Macro</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>expect(function, &#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expected once, in the specified order, for the same function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>always_expect(function, &#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expect this behavior from here onwards</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>never_expect(function)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">From this point this mocked function must never be called</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can specify constraints and behaviours for each expectation (except for <code>never_expect()</code> naturally).
A constraint places restrictions on the parameters (and will tell you if the expected restriction was not met), and a behaviour specifies what the mock should do if the parameter constraints are met.</p>
</div>
<div class="paragraph">
<p>A parameter constraint is defined using the <code>when(parameter, constraint)</code> macro.
It takes two parameters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Parameter</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parameter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the parameter to the mock function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>constraint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A constraint placed on that parameter</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There is a multitude of constraints available (actually, exactly the same as for the assertions we saw earlier):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Constraint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_contents_of(pointer, size_of_contents)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bytes/Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_contents_of(pointer, size_of_contents)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bytes/Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contains_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_not_contain_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>begins_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For the double valued constraints you can set the number of significant digits to consider a match with a call to <code>significant_figures_for_assert_double_are(int figures)</code>.
The <a href="#floating_point_comparison_algorithm">section on how to work with doubles</a> has a more detailed discussion of the algorithm used for comparing floating point numbers.</p>
</div>
<div class="paragraph">
<p>Then there are a couple of ways to return results from the mocks.
They all provide ways to return various types of values through <code>mock()</code>.
In your mocked function you can then simply return that value, or manipulate it as necessary.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Macro</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>mock()</code> will&#8230;&#8203;</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_return(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return <code>value</code>, for integer types</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_return_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return <code>value</code> as a "boxed double", for double floats (required because of C&#8217;s type coercion rules which would otherwise convert a double into an int)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_return_by_value(struct, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return a pointer to an allocated copy of the <code>struct</code> that can be copied and returned by value from the mocked function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_set_contents_of_output_parameter(parameter_name, pointer_to_value, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">write <code>size</code> bytes from the pointed out value (<code>pointer_to_value</code>) into where the referenced out parameter (<code>parameter_name</code>) is pointing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_capture_parameter(parameter_name, local_variable)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">capture the value of the parameter and store it in the named local variable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>with_side_effect(function, pointer_to_data)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">call the side effect <code>function</code> and pass <code>pointer_to_data</code> to it</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong><code>will_return_double()</code></strong>: The "boxed double" returned by <code>mock()</code> have to be "unboxed" by the caller see <a href="#double_mocks">Double Mocks</a> for details.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong><code>will_return_by_value</code></strong>: The memory allocated for the copy of the struct returned by <code>mock()</code> needs to be deallocated by the caller or it will be lost. You can do this with the code in the <code>Box</code> example below.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong><code>will_set_contents_of_output_parameter</code></strong>: The data to set must be correct at the time of the call to the mock function, and not be overwritten or released between the call to the <code>expect()</code> and the mock function. See <a href="#refactoring-tests">Refactoring Tests with Mocks - CAUTION!</a> for details.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong><code>will_set_contents_of_output_parameter</code></strong>: The previous name of this macro was <code>will_set_contents_of_parameter</code> and it is still available. The new name is prefered due to readability.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong><code>will_capture_parameter</code></strong>: The local variable to capture the value in must be live at the time of the call to the mock function, so using a local variable in a function called by your test will not work. See <a href="#refactoring-tests">Refactoring Tests with Mocks - CAUTION!</a> for details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_combining_expectations">4.5. Combining Expectations</h3>
<div class="paragraph">
<p>You can combine the expectations for a <code>mock()</code> in various ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">  expect(mocked_file_writer,
        when(data, is_equal_to(42)),
        will_return(EOF));
  expect(mocked_file_reader,
        when(file, is_equal_to_contents_of(&amp;FD, sizeof(FD))),
        when(input, is_equal_to_string("Hello world!"),
        with_side_effect(&amp;update_counter, &amp;counter),
        will_set_contents_of_output_parameter(status, FD_CLOSED, sizeof(bool))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple <code>when()</code> are specified they all need to be fullfilled.
You can of course only have one for each of the parameters of your mock function.</p>
</div>
<div class="paragraph">
<p>You can also have multiple <code>will_set_contents_of_output_parameter()</code> in an expectation, one for each reference parameter, but naturally only one <code>will_return()</code>.</p>
</div>
<div class="paragraph">
<p>To ensure that a specific call happens <code>n</code> times the macro <code>times(number_times_called)</code> can be passed as a constraint to a specific call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">  expect(mocked_file_writer,
        when(data, is_equal_to(42)),
        times(1));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This feature only works for <code>expect()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_order_of_constraints">4.6. Order of constraints</h3>
<div class="paragraph">
<p>When you have multiple constraints in an <code>expect</code> the order in which they are executed is not always exactly then order in which they where given.</p>
</div>
<div class="paragraph">
<p>First all constraints are inspected for validity, such as if the parameter name given cannot be found, but primarily to see if the parameters, if any, matche the actual parameters in the call.</p>
</div>
<div class="paragraph">
<p>Then all read-only constraints are processed, followed by constraints that set contents.</p>
</div>
<div class="paragraph">
<p>Finally all side effect constraints are executed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_order_of_multiple_expects">4.7. Order of multiple `expect`s</h3>
<div class="paragraph">
<p>The expections still need to respect the order of calling, so if we call the function
<code>mocker_file_writer</code> with the following pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">  mocked_file_writer(42);
  mocked_file_writer(42);
  mocked_file_writer(43);
  mocked_file_writer(42);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expectation code should look like the following</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">  expect(mocked_file_writer,
        when(data, is_equal_to(42)),
        times(2));
  expect(mocked_file_writer,
        when(data, is_equal_to(43)),
        times(1));
  expect(mocked_file_writer,
        when(data, is_equal_to(42)),
        times(1));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_out_parameters">4.8. Handling out-parameters</h3>
<div class="paragraph">
<p>TBD. Hint: this involves using <code>will_set_contents_of_output_parameter()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_returning_struct">4.9. Returning <code>struct</code></h3>
<div class="paragraph">
<p>If the function we are mocking returns structs by value, then our mock function need to do that too.
To do this we must use specific return macro, <code>will_return_by_value()</code>.
Below is some example code using an imaginary struct typedef&#8217;ed as <code>Struct</code> and a corresponding function, <code>retrieve_struct()</code>, which we want to mock.</p>
</div>
<div class="paragraph">
<p>The underlying mechanism of this is that in the test we create the struct that we want to return.
The macro <code>will_return_by_value()</code> then copies that to a dynamically allocated area, saving it so that a pointer to that area can be returned by <code>mock()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">  Struct returned_struct = {...};
  expect(retrieve_struct,
         will_return_by_value(returned_struct, sizeof(Struct));
         /* `returned_struct` has been copied to an allocated area */</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In some future version the <code>size</code> argument will be removed from <code>will_return_by_value()</code> size since the macro can easily calculate that for you.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The mock function will then look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Struct retrieve_struct() {
   return *(Struct *)mock();       /* De-reference the returned pointer to the allocated area */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would cause a memory leak since the area allocated by the <code>return_by_value()</code> macro is not deallocated.
And in many scenarious this might not be a big problem, and you could make do with that simple version.</p>
</div>
<div class="paragraph">
<p>We might want to be sure, e.g. if we want to use <code>valgrind</code> on when unittesting to catch leaks early.
Then we don&#8217;t want our unittests to pollute the actual leakage analysis.</p>
</div>
<div class="paragraph">
<p>In that case the mock function needs to free up the area that was automatically allocated by <code>will_return_by_value()</code>.
The pointer returned by <code>mock()</code> will point to that area.
So, here&#8217;s a better, although slightly more complicated, version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Struct retrieve_struct() {
    Struct *struct_p = (Struct *)mock(); /* Get the pointer */
    Struct the_struct = *struct_p;       /* Dereference to get a struct */
    free(struct_p);                      /* Deallocate the returned area */
    return the_struct;                   /* Finally we can return the struct by value */
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mocking_struct_parameters">4.10. Mocking <code>struct</code> Parameters</h3>
<div class="paragraph">
<p>Modern C standards allows function parameters to be <code>struct</code>s by value.
Since our <code>mock()</code> only can handle scalar values this presents a bit of a conundrum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct {
    int i;
    char *string;
} Struct;

int function_taking_struct(Struct s) {
    return (int)mock(?);</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we also can not compare a non-scalar value with any of the <code>is_equal_to&#8230;&#8203;()</code> constraint macros in the <code>expect()</code> call.
Also remember that the C language does not allow comparing non-scalar values using <code>==</code>.</p>
</div>
<div class="paragraph">
<p>There are a couple of ways to handle this and which one to select depends on what you want to do.</p>
</div>
<div class="sect3">
<h4 id="_checking_single_struct_fields">4.10.1. Checking Single <code>struct</code> Fields</h4>
<div class="paragraph">
<p>In an <code>expect(when())</code> we probably want to check one, or more, of the fields in the struct.</p>
</div>
<div class="paragraph">
<p>Since <code>mock()</code> actually can "mock" anything we can use a normal field expression to access the value we want to check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int function_checking_a_field(Struct s) {
    return (int)mock(s.i);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The trick here is that <code>mock()</code> just saves the "name", as a string, given as the argument, in this case "s.i", and pair it with the value of that expression.
There is no requirement that the "name" is actually a parameter, it can be anything.
The only thing to remember is that the exact same string needs to be used when invoking <code>when()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    expect(function_checking_a_field, when(s.i, is_equal_to(12)),
           will_return(12));</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do this with as many fields as you need.
And there is no (reasonable) limit to how many arguments <code>mock()</code> can take, so you can start with the ones that you require and add more as you need them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int function_checking_multiple_fields(Struct s) {
    return (int)mock(s.i, s.string);
}

Ensure(StructParameters, can_mock_muultiple_fields_in_parameter) {
    Struct struct_to_send = { .i = 13, .string = "hello world!" };

    expect(function_checking_multiple_fields,
           when(s.i, is_equal_to(13)),
           when(s.string, begins_with_string("hello")),
           will_return(13));

    assert_that(function_checking_multiple_fields(struct_to_send), is_equal_to(13));
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In both example we use an explicit value in <code>will_return()</code> instead of the value of the field, "s.i".
That is because it is not possible to use the value of a mocked value in <code>will_return()</code>.
Remember, <code>expect()</code> does early collection.
At the time of executing it, there is no parameter available, so the value must come from that run-time environment.
Also, since we already explicitly know the value, we have to use it in the <code>when()</code> clause, there will be no uncertainty of what it should be.
The only concern might be duplication of an explicit value, but that is not a big problem in a unittest, clarity over DRY, and you can easily fix that with a suitably named local variable.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_capturing_parameters">4.11. Capturing Parameters</h3>
<div class="paragraph">
<p>TBD. Hint: this involves using <code>will_capture_parameter()</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_special_cases">5. Special Cases</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_working_with_doubles">5.1. Working with <code>doubles</code></h3>
<div class="paragraph">
<p>We are not talking about
<a href="http://www.hostettler.net/blog/2014/05/18/fakes-stubs-dummy-mocks-doubles-and-all-that/">test doubles</a>
here, but about values of C/C++ <code>double</code> type (a.k.a. double float.)</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> is designed to make it easy and natural to write assertions and expectations.
Many functions can be used for multiple data types, e.g. <code>is_equal_to()</code> applies to all integer type values, actually including pointers.</p>
</div>
<div class="paragraph">
<p>But the C language has its quirks.
One of them is the fact that it is impossible to inspect the datatypes of values during run-time.
This has e.g. forced the introduction of <code>is_equal_to_string()</code> to enable string comparisons.</p>
</div>
<div class="sect3">
<h4 id="_assertions_and_constraints">5.1.1. Assertions and Constraints</h4>
<div class="paragraph">
<p>When it comes to double typed values this has spilled over even further.
For double typed values we have</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Constraint</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_double(value)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_double(value)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than_double(value)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than_double(value)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>But there is also the special assert that you must use when asserting doubles</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_that_double(expected, constraint)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>and the utility function</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Utility</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>significant_figures_for_assert_double_are(int figures)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>And of course they are designed to go together.
So, if you want to assert an expression yeilding a <code>double</code> typed value, you need to combine them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Doubles, can_assert_double_values) {
    significant_figures_for_assert_double_are(3);
    assert_that_double(3.14, is_equal_to_double(5.0));
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You have to use <code>assert_that_double()</code> and <code>is_equal_to_double()</code>
together.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>and you would get</p>
</div>
<div class="listingblock">
<div class="content">
<pre>double_tests.c:13: Failure: can_assert_double_values 
	Expected [3.14] to [equal double] [5.0] within [3] significant figures
		actual value:			[3.140000]
		expected value:			[5.000000]</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="double_mocks">5.1.2. Double Mocks</h4>
<div class="paragraph">
<p>The general mechanism <strong>Cgreen</strong> uses to transport values to and from mock functions is based on the simple idea that most types fit into a "large" integer and can be type converted to and from whatever type you need.</p>
</div>
<div class="paragraph">
<p>Since a <code>double float</code> will not fit into the same memory space as an integer <strong>Cgreen</strong> handles that by encapsulating ("boxing") the <code>double</code> into an area which is represented by the pointer to it.
And that pointer can fit into the integer type value (<code>intptr_t</code>) that <strong>Cgreen</strong> uses to transport values into and out of <code>mock()</code>.
To get the value back you "unbox" it.</p>
</div>
<div class="paragraph">
<p>There are two possible uses of <code>double</code> that you need to be aware of</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When a parameter to the mocked function is of <code>double</code> type and needs to be matched in an constraint in an <code>expect()</code> call.</p>
</li>
<li>
<p>When the mock function itself should return a <code>double</code> type value.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the test you should use the special <code>double</code> type constraints and the <code>will_return_double()</code> convenience function.
In the mock function you will have to take care to box and unbox as required.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Boxing and unboxing in mock functions</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>box_double(double value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrap the value in an allocated
                                     memory area and return a pointer
                                     to it</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unbox_double(BoxedDouble *box)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unwrap the value by freeing the
                                     area and returning the value</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here&#8217;s an example of that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static double double_out(int i, double d) {
    return unbox_double(mock(i, box_double(d))); <i class="conum" data-value="1"></i><b>(1)</b>
}

Ensure(Doubles, can_be_arguments_to_mock_and_returned) {
    expect(double_out,
           when(i, is_equal_to(15)),
           when(d, is_equal_to_double(31.32)), <i class="conum" data-value="2"></i><b>(2)</b>
           will_return_double(3.1415926));     <i class="conum" data-value="3"></i><b>(3)</b>
    assert_that_double(double_out(15, 31.32), is_equal_to_double(3.1415926));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We can see that the parameter <code>d</code> to the mock function, since it is a
<code>double</code>, it will have to be used as <code>box_double(d)</code> in the call to
<code>mock()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The corresponding <code>expect()</code> uses a double constraint.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The mock function in this small example also returns a <code>double</code>.
The <code>expect()</code> uses <code>will_return_double()</code> so the mock function needs to unbox the return value from <code>mock()</code> to be able to return the <code>double</code> type value.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Strange errors may occur if you box and/or unbox or combine <code>double</code> constraints incorrectly.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="floating_point_comparison_algorithm">5.1.3. Details of Floating Point Comparison Algorithm</h4>
<div class="paragraph">
<p>The number of significant digits set with <code>significant_figures_for_assert_double_are()</code> specifies a <em>relative</em> tolerance.
Cgreen considers two double precision numbers x and y equal if their difference normalized by the larger of the two is smaller than 10^(1 - significant_figures)^.
Mathematically, we check that |x - y| &lt; max(|x|, |y|) * 10^(1 - significant_figures)^.</p>
</div>
<div class="paragraph">
<p>Well documented subtleties arise when comparing floating point numbers close to zero using this algorithm.
The article <a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing Floating Point Numbers, 2012 Edition</a> by Bruce Dawson has an excellent discussion of the issue.
The essence of the problem can be appreciated if we consider the special case where y == 0.
In that case, our condition reduces to |x| &lt; |x| * 10^(1 - significant_figures)^.
After cancelling |x| this simplifies to 1 &lt; 10^(1 - significant_figures)^.
But this is only true if significant_figures &lt; 1.
In words this can be summarized by saying that, in a relative sense, <em>all</em> numbers are very different from zero.
To circumvent this difficulty we recommend to use a constraint of the following form when comparing numbers close to zero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">assert_that(fabs(x - y) &lt; abs_tolerance);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_cgreen_with_c">5.2. Using Cgreen with C++</h3>
<div class="paragraph">
<p>The examples in this guide uses the C langauge to shows how to use <strong>CGreen</strong>. You can also use <strong>CGreen</strong> with C++.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following needs expansion and more details as the support for C++ is extended.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All you have to do is</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>cgreen</code> namespace by adding <code>using namespace cgreen;</code>
at the beginning of the file with your tests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is also one extra feature when you use C++, the <code>assert_throws</code> function.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use the autodiscovering runner, as described in <a href="#runner">Using the Runner</a>, and thus link your tests into a shared library, don&#8217;t forget to link it with the same C++ library that was used to create the <code>cgreen-runner</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context_system_under_test_suites">6. Context, System Under Test &amp; Suites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As mentioned earlier, <strong>Cgreen</strong> promotes the behaviour driven style of test driving code.
The thinking behind BDD is that we don&#8217;t really want to test anything, if we just could specify the behaviour of our code and ensure that it actually behaves this way we would be fine.</p>
</div>
<div class="paragraph">
<p>This might seem like an age old dream, but when you think about it, there is actually very little difference in the mechanics from vanillla TDD.
First we write how we want it, then implement it.
But the small change in wording, from `test´ to `behaviour´, from `test that´ to `ensure that´, makes a huge difference in thinking, and also very often in quality of the resulting code.</p>
</div>
<div class="sect2">
<h3 id="_the_sut_system_under_test">6.1. The SUT - System Under Test</h3>
<div class="paragraph">
<p>Since BDD talks about behaviour, there has to be something that we can talk about as having that wanted behaviour.
This is usually called the SUT, the System Under Test.
The "system" might be whatever we are testing, such as a C module ("MUT"), class ("CUT"), object ("OUT"), function ("FUT") or method ("MUT").
We will stick with SUT in this document.
To use <strong>Cgreen</strong> in BDD-ish mode you must define a name for it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
Describe(SUT);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> supports C++ and there you naturally have the objects and also the Class Under Test.
But in plain C you will have to think about what is actually the "class" under test.
E.g. in <code>sort_test.c</code> you might see</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
Describe(Sorter);

Ensure(Sorter, can_sort_an_empty_list) {
  assert_that(sorter(NULL), is_null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example you can clearly see what difference the BDD-ish style makes when it comes to naming.
Convention, and natural language, dictates that typical names for what TDD would call tests, now starts with 'can' or 'finds' or other verbs, which makes the specification so much easier to read.</p>
</div>
<div class="paragraph">
<p>Yes, I wrote 'specification'. Because that is how BDD views what TDD basically calls a test suite. The suite specifies the behaviour of a `class´.
(That&#8217;s why some BDD frameworks draw on 'spec', like <strong>RSpec</strong>.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_contexts_and_before_and_after">6.2. Contexts and Before and After</h3>
<div class="paragraph">
<p>The complete specification of the behaviour of a SUT might become long and require various forms of setup.
When using TDD style you would probably break this up into multiple suites having their own <code>setup()</code> and <code>teardown()</code>.</p>
</div>
<div class="paragraph">
<p>With BDD-ish style we could consider a suite as a behaviour specification for our SUT 'in a particular context'.
E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

Describe(shopping_basket_for_returning_customer);

Customer *customer;

BeforeEach(shopping_basket_for_returning_customer){
  customer = create_test_customer();
  login(customer);
}

AfterEach(shopping_basket_for_returning_customer) {
  logout(customer);
  destroy_customer(customer);
}

Ensure(shopping_basket_for_returning_customer, allows_use_of_discounts) {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The 'context' would then be <code>shopping_basket_for_returning_customer</code>, with the SUT being the shopping basket 'class'.</p>
</div>
<div class="paragraph">
<p>So 'context', 'system under test' and 'suite' are mostly interchangable concepts in <strong>Cgreen</strong> lingo.
It&#8217;s a named group of 'tests' that share the same <code>BeforeEach</code> and <code>AfterEach</code> and lives in the same source file.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="auto-discovery">7. Automatic Test Discovery</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_forgot_to_add_your_test">7.1. Forgot to Add Your Test?</h3>
<div class="paragraph">
<p>When we write a new test we focus on the details about the test we are trying to write.
And writing tests is no trivial matter so this might well take a lot of brain power.</p>
</div>
<div class="paragraph">
<p>So, it comes as no big surprise, that sometimes you write your test and then forget to add it to the suite.
When we run it it appears that it passed on the first try!
Although this <strong>should</strong> really make you suspicious, sometimes you get so happy that you just continue with churning out more tests and more code.
It&#8217;s not until some (possibly looong) time later that you realize, after much headache and debugging, that the test did not actually pass.
It was never even run!</p>
</div>
<div class="paragraph">
<p>There are practices to minimize the risk of this happening, such as always running the test as soon as you can set up the test.
This way you will see it fail before trying to get it to pass.</p>
</div>
<div class="paragraph">
<p>But it is still a practice, something we, as humans, might fail to do at some point.
Usually this happens when we are most stressed and in need of certainty.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_solution_the_cgreen_runner">7.2. The Solution - the 'cgreen-runner'</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> gives you a tool to avoid not only the risk of this happening, but also the extra work and extra code.
It is called the <code>cgreen-runner</code>.</p>
</div>
<div class="paragraph">
<p>The <code>cgreen-runner</code> should come with your <strong>Cgreen</strong> installation if your platform supports the technique that is required, which is 'programatic access to dynamic loading of libraries'.
This means that a program can load an external library of code into memory and inspect it.
Kind of self-inspection, or reflexion.</p>
</div>
<div class="paragraph">
<p>So all you have to do is to build a dynamically loadable library of all tests (and of course your objects under test and other necessary code).
Then you can run the <code>cgreen-runner</code> and point it to the library.
The runner will then load the library, enumerate all tests in it, and run every test.</p>
</div>
<div class="paragraph">
<p>It&#8217;s automatic, and there is nothing to forget.</p>
</div>
</div>
<div class="sect2">
<h3 id="runner">7.3. Using the Runner</h3>
<div class="paragraph">
<p>Assuming your tests are in <code>first_test.c</code> the typical command to build your library using <code>gcc</code> would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -shared -o first_test.so -fPIC first_test.c -lcgreen</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-fPIC</code> means to generate 'position independent code' which is required if you want to load the library dynamically.
To explicitly state this is required on many platforms.</p>
</div>
<div class="paragraph">
<p>How to build a dynamically loadable shared library might vary a lot depending on your platform.
Can&#8217;t really help you there, sorry!</p>
</div>
<div class="paragraph">
<p>As soon as we have linked it we can run the tests using the <code>cgreen-runner</code> by just giving it the shared, dynamically loadable, object library as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner first_test.so
Running "first_tests" (2 tests)...
first_tests.c:12: Failure: Cgreen -&gt; fails_this_test 
	Expected [0 == 1] to [be true]

  "Cgreen": 1 pass, 1 failure in 42ms.
Completed "first_tests": 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>More or less exactly the same output as when we ran our first test in the beginning of this quickstart tutorial. We can see that the top level of the tests will be named as the library it was discovered in, and the second level is the context for our System Under Test, in this case 'Cgreen'.
We also see that the context is mentioned in the failure message, giving a fairly obvious <code>Cgreen &#8594; fails_this_test</code>.</p>
</div>
<div class="paragraph">
<p>Now we can actually delete the main function in our source code.
We don&#8217;t need all this, since the runner will discover all tests automatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Cgreen, passes_this_test);
    add_test_with_context(suite, Cgreen, fails_this_test);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It always feel good to delete code, right?</p>
</div>
<div class="paragraph">
<p>We can also select which test to run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner first_test.so Cgreen:this_test_should_fail
Running "first_tests" (1 test)...
first_tests.c:12: Failure: Cgreen -&gt; fails_this_test 
	Expected [0 == 1] to [be true]

  "Cgreen": 1 failure in 42ms.
Completed "first_tests": 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>We recommend the BDD notation to discover tests, and you indicate which context the test we want to run is in.
In this example it is <code>Cgreen</code> so the test should be refered to as <code>Cgreen:this_test_should_fail</code>.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t use the BDD notation there is actually a context anyway, it is called <code>default</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="runner-options">7.4. Cgreen Runner Options</h3>
<div class="paragraph">
<p>Once you get the build set up right for the cgreen-runner everything
is fairly straight-forward. But you have a few options:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">--xml &lt;prefix&gt;</dt>
<dd>
<p>Instead of messages on stdout with the TextReporter,
write results into one XML-file per suite or context,
compatible with Hudson/Jenkins CI. The filename(s)
will be <code>&lt;prefix&gt;-&lt;suite&gt;.xml</code></p>
</dd>
<dt class="hdlist1">--suite &lt;name&gt;</dt>
<dd>
<p>Name the top level suite</p>
</dd>
<dt class="hdlist1">--no-run</dt>
<dd>
<p>Don&#8217;t run the tests</p>
</dd>
<dt class="hdlist1">--verbose</dt>
<dd>
<p>Show progress information and list discovered tests</p>
</dd>
<dt class="hdlist1">--colours</dt>
<dd>
<p>Use colours (or colors) to emphasis result (requires ANSI-capable terminal)</p>
</dd>
<dt class="hdlist1">--quiet</dt>
<dd>
<p>Be more quiet</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>verbose</code> option is particularly handy since it will give you the actual names of all tests discovered.
So if you have long test names you can avoid mistyping them by copying and pasting from the output of <code>cgreen-runner --verbose</code>.
It will also give the mangled name of the test which should make it easier to find in the debugger.
Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Discovered Cgreen:fails_this_test (CgreenSpec__Cgreen__fails_this_test__)
Discovered Cgreen:passes_this_test (CgreenSpec__Cgreen__passes_this_test__)
Discovered 2 test(s)
Opening [first_tests.so] to only run one test: 'Cgreen:fails_this_test' ...
Running "first_tests" (1 test)...
first_tests.c:12: Failure: Cgreen -&gt; fails_this_test 
	Expected [0 == 1] to [be true]

  "Cgreen": 1 failure in 42ms.
Completed "first_tests": 1 failure in 42ms.</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_selecting_tests_to_run">7.5. Selecting Tests To Run</h3>
<div class="paragraph">
<p>You can name a single test to be run by giving it as the last argument on the command line.
The name should be in the format <code>&lt;SUT&gt;:&lt;test&gt;</code>.
If not obvious you can get that name by using the <code>--verbose</code> command option which will show you all tests discovered and both there C/C++ and Cgreen names.
Copying the Cgreen name from that output is an easy way to run only that particular test.
When a single test is named it is run using <code>run_single_test()</code>.
As described in <a href="#tdd_with_cgreen">Five Minutes Doing TDD with Cgreen</a> this means that it is <em>not</em> protected by <code>fork()</code>-ing it to run in its own process.</p>
</div>
<div class="paragraph">
<p>The <code>cgreen-runner</code> supports selecting tests with limited pattern matching.
Using an asterisk as a simple 'match many' symbol you can say things like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner &lt;library&gt; Cgreen:*
$ cgreen-runner &lt;library&gt; C*:*this*</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_test_libraries">7.6. Multiple Test Libraries</h3>
<div class="paragraph">
<p>You can run tests in multiple libraries in one go by adding them to the <code>cgreen-runner</code> command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner first_set.so second_set.so ...</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setup_teardown_and_custom_reporters">7.7. Setup, Teardown and Custom Reporters</h3>
<div class="paragraph">
<p>The <code>cgreen-runner</code> will only run setup and teardown functions if you use the BDD-ish style with <code>BeforeEach()</code> and <code>AfterEach()</code> as described above.
The runner does not pickup <code>setup()</code> and <code>teardown()</code> added to suites, because it actually doesn&#8217;t run suites.
It discovers all tests and runs them one by one.
The macros required by the BDD-ish style ensures that the corresponding <code>BeforeEach()</code> and <code>AfterEach()</code> are run before and after each test.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The <code>cgreen-runner</code> <em>will</em> discover your tests in a shared library even if you don&#8217;t use the BDD-ish style.
But it will not be able to find and run the <code>setup()</code> and/or <code>teardown()</code> attached to your suite(s).
This will probably cause your tests to fail or crash.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In case you have non-BDD style tests <em>without</em> any <code>setup()</code> and/or <code>teardown()</code> you can still use the runner.
The default suite/context where the tests live in this case is called <code>default</code>.
But why don&#8217;t you convert your tests to BDD notation?
This removes the risk of frustrating trouble-shooting when you added <code>setup()</code> and <code>teardown()</code> and can&#8217;t understand why they are not run&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So, the runner encourages you to use the BDD notation.
But since we recommend that you do anyway, that&#8217;s no extra problem if you are starting out from scratch.
But see <a href="#changing_style">Changing Style</a> for some easy tips on how to get you there if you already have non-BDD tests.</p>
</div>
<div class="paragraph">
<p>You can choose between the TextReporter, which we have been seeing so far, and the built-in JUnit/Ant compatible XML-reporter using the <code>--xml</code> option.
But it is not currently possible to use custom reporters as outlined in <a href="#reporter">Changing Cgreen Reporting</a> with the runner.</p>
</div>
<div class="paragraph">
<p>If you require another custom reporter you need to resort to the standard, programatic, way of invoking your tests.
For now&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="xensure">7.8. Skipping Tests</h3>
<div class="paragraph">
<p>Sometimes you find that you need to temporarily remove a test, perhaps to do a refactoring when you have a failing test.
Ignoring that test will allow you to do the refactoring while still in the green.</p>
</div>
<div class="paragraph">
<p>An old practice is then to comment it out.
That is a slightly cumbersome.
It is also hazardous habit as there is no indication of a missing test if you forget to uncomment it when you are done.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> offers a much better solution.
You can just add an 'x' infront of the <code>Ensure</code> for the test and that test will be skipped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">...
xEnsure(Reader, ...) {
  ...
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this method, it is a one character change to temporarily ignore, and un-ignore, a test.
It is also easily found using text searches through a complete source tree.
<strong>Cgreen</strong> will also tally the skipped tests, so it is clearly visible that you have some skipped test when you run them.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also programmatically decide to skip a test depending on some run-time information.
You do that simply by checking for the condition and calling <code>skip_test()</code> which will tally the test as skipped.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>skip_test()</code> does <strong>not</strong> exit your test function so you need to take care that continuing after the call does not trigger any undecided behaviour.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="changing_style">8. Changing Style</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you already have some TDD style <strong>Cgreen</strong> test suites, it is quite easy to change them over to BDD-ish style.
Here are the steps required</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add <code>Describe(SUT);</code></p>
</li>
<li>
<p>Turn your current setup function into a <code>BeforeEach()</code> definition by changing its signature to match the macro, or simply call the existing setup function from the BeforeEach().
If you don&#8217;t have any setup function you still need to define an empty <code>BeforeEach()</code>.</p>
</li>
<li>
<p>Ditto for <code>AfterEach()</code>.</p>
</li>
<li>
<p>Add the SUT to each <code>Ensure()</code> by inserting it as a first parameter.</p>
</li>
<li>
<p>Change the call to add the tests to <code>add_test_with_context()</code> by
adding the name of the SUT as the second parameter.</p>
</li>
<li>
<p>Optionally remove the calls to <code>set_setup()</code> and <code>set_teardown()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Done.</p>
</div>
<div class="paragraph">
<p>If you want to continue to run the tests using a hand-coded runner,
you can do that by keeping the setup and teardown functions and their
corresponding <code>set_</code>-calls.</p>
</div>
<div class="paragraph">
<p>It&#8217;s nice that this is a simple process, because you can change over from TDD style to BDD-ish style in small steps.
You can convert one source file at a time, by just following the recipe above.
Everything will still work as before but your tests and code will likely improve.</p>
</div>
<div class="paragraph">
<p>And once you have changed style you can fully benefit from the
automatic discovery of tests as described in <a href="#auto-discovery">Automatic Test Discovery</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reporter">9. Changing Cgreen Reporting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_replacing_the_reporter">9.1. Replacing the Reporter</h3>
<div class="paragraph">
<p>In every test suite so far, we have run the tests with this line&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">return run_test_suite(our_tests(), create_text_reporter());</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can change the reporting mechanism just by changing this call to create another reporter.</p>
</div>
</div>
<div class="sect2">
<h3 id="builtin_reporters">9.2. Built-in Reporters</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> has the following built-in reporters that you can choose from when your code runs the test suite.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Reporter</th>
<th class="tableblock halign-left valign-top">Purpose</th>
<th class="tableblock halign-left valign-top">Signature</th>
<th class="tableblock halign-left valign-top">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Human readable, with clear messages</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create_text_reporter(void)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">XML</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANT/Jenkins compatible</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create_xml_reporter(const char *file_prefix)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>file_prefix</code> is the prefix of the XML files generated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CUTE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CUTE Eclipse-plugin (<a href="http://cute-test.org" class="bare">http://cute-test.org</a>) compatible output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create_cute_reporter(void)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CDash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CMake (<a href="http://cmake.org" class="bare">http://cmake.org</a>) dashboard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create_cdash_reporter(CDashInfo *info)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>info</code> is a structure defined in <code>cdash_reporter.h</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If you write a runner function like in most examples above, you can just substitute which runner to create.
If you use the <code>cgreen-runner</code> (<a href="#auto-discovery">Automatic Test Discovery</a>) to dynamically find all your tests you can force it to use the XML-reporter with the <code>-x &lt;prefix&gt;</code> option.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently <code>cgreen-runner</code> only supports the built-in text and XML reporters.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_rolling_our_own">9.3. Rolling Our Own</h3>
<div class="paragraph">
<p>Although <strong>Cgreen</strong> has a number of options, there are times when you&#8217;d like a different output from the reporter, the CUTE and CDash reporters are examples that grew out of such a need.</p>
</div>
<div class="paragraph">
<p>Perhaps your Continuous Integration server want the result in a different format, or you just don&#8217;t like the text reporter&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Writing your own reporter is supported.
And we&#8217;ll go through how that can be done using an XML-reporter as an example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Cgreen</strong> already has an XML-reporter compatible with ANT/Jenkins, see <a href="#builtin_reporters">Built-in Reporters</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the code for <code>create_text_reporter()</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">TestReporter *create_text_reporter(void) {
    TestReporter *reporter = create_reporter();
    if (reporter == NULL) {
        return NULL;
    }
    reporter-&gt;start_suite = &amp;text_reporter_start_suite;
    reporter-&gt;start_test = &amp;text_reporter_start_test;
    reporter-&gt;show_fail = &amp;show_fail;
    reporter-&gt;show_skip = &amp;show_skip;
    reporter-&gt;show_incomplete = &amp;show_incomplete;
    reporter-&gt;finish_test = &amp;text_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;text_reporter_finish;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TestReporter</code> structure contains function pointers that control the reporting.
When called from <code>create_reporter()</code> constructor, these pointers are set up with functions that display nothing.
The text reporter code replaces these with something more dramatic, and then returns a pointer to this new object.
Thus the <code>create_text_reporter()</code> function effectively extends the object from <code>create_reporter()</code>.</p>
</div>
<div class="paragraph">
<p>The text reporter only outputs content at the start of the first test, at the end of the test run to display the results, when a failure occurs, and when a test fails to complete.
A quick look at the <code>text_reporter.c</code> file in <strong>Cgreen</strong> reveals that the overrides just output a message and chain to the versions in <code>reporter.h</code>.</p>
</div>
<div class="paragraph">
<p>To change the reporting mechanism ourselves, we just have to know a little about the methods in the <code>TestReporter</code> structure.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_testreporter_structure">9.4. The TestReporter Structure</h3>
<div class="paragraph">
<p>The <strong>Cgreen</strong> <code>TestReporter</code> is a pseudo class that looks
something like&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct _TestReporter TestReporter;
struct _TestReporter {
    void (*destroy)(TestReporter *reporter);
    void (*start_suite)(TestReporter *reporter, const char *name, const int count);
    void (*start_test)(TestReporter *reporter, const char *name);
    void (*show_pass)(TestReporter *reporter, const char *file, int line,
                                   const char *message, va_list arguments);
    void (*show_skip)(TestReporter *reporter, const char *file, int line);
    void (*show_fail)(TestReporter *reporter, const char *file, int line,
                                   const char *message, va_list arguments);
    void (*show_incomplete)(TestReporter *reporter, const char *file, int line,
                                   const char *message, va_list arguments);
    void (*assert_true)(TestReporter *reporter, const char *file, int line, int result,
                                   const char * message, ...);
    void (*finish_test)(TestReporter *reporter, const char *file, int line);
    void (*finish_suite)(TestReporter *reporter, const char *file, int line);
    int passes;
    int failures;
    int exceptions;
    void *breadcrumb;
    int ipc;
    void *memo;
    void *options;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first block are the methods that can be overridden:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>void (*destroy)(TestReporter *reporter)</code></dt>
<dd>
<p>This is the destructor for the default structure.
If this is overridden, then the overriding function must call <code>destroy_reporter(TestReporter *reporter)</code> to finish the clean up.</p>
</dd>
<dt class="hdlist1"><code>void (*start_suite)(TestReporter *reporter, const char *name, const int count)</code></dt>
<dd>
<p>This is the first of the callbacks.
At the start of each test suite <strong>Cgreen</strong> will call this method on the reporter with the name of the suite being entered and the number of tests in that suite.
The default version keeps track of the stack of tests in the <code>breadcrumb</code> pointer of <code>TestReporter</code>.
If you make use of the breadcrumb functions, as the defaults do, then you will need to call <code>reporter_start_suite()</code> to keep the book-keeping in sync.</p>
</dd>
<dt class="hdlist1"><code>void (*start_test)(TestReporter *reporter, const char *name)</code></dt>
<dd>
<p>At the start of each test <strong>Cgreen</strong> will call this method on the reporter with the name of the test being entered.
Again, the default version keeps track of the stack of tests in the <code>breadcrumb</code> pointer of <code>TestReporter</code>.
If you make use of the breadcrumb functions, as the defaults do, then you will need to call <code>reporter_start_test()</code> to keep the book-keeping in sync.</p>
</dd>
<dt class="hdlist1"><code>void (*show_pass)(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments)</code></dt>
<dd>
<p>This method is initially empty as most reporters see little point in reporting passing tests (but you might do), so there is no need to chain the call to any other function.
Besides the pointer to the reporter structure, <strong>Cgreen</strong> also passes the file name of the test, the line number of failed assertion, the message to show and any additional parameters to substitute into the message.
The message comes in as <code>printf()</code> style format string, and so the variable argument list should match the substitutions.</p>
</dd>
<dt class="hdlist1"><code>void (*show_fail)(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments)</code></dt>
<dd>
<p>The partner of <code>show_pass()</code>, and the one you&#8217;ll likely overload first.</p>
</dd>
<dt class="hdlist1"><code>void (*show_skip)(TestReporter *reporter, const char *file, int line)</code></dt>
<dd>
<p>This method will be called when a skipped test is encountered, see <a href="#xensure">Skipping Tests</a>.</p>
</dd>
<dt class="hdlist1"><code>void (*show_incomplete)(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments)</code></dt>
<dd>
<p>When a test fails to complete, this is the handler that is called.
As it&#8217;s an unexpected outcome, no message is received, but we do get the name of the test.
The text reporter combines this with the breadcrumb to produce the exception report.</p>
</dd>
<dt class="hdlist1"><code>void (*assert_true)(TestReporter *reporter, const char *file, int line, int result, const char * message, &#8230;&#8203;)</code></dt>
<dd>
<p>This is not normally overridden and is really internal.
It is the raw entry point for the test messages from the test suite.
By default it dispatches the call to either <code>show_pass()</code> or <code>show_fail()</code>.</p>
</dd>
<dt class="hdlist1"><code>void (*finish_test)(TestReporter *reporter, const char *file, int line)</code></dt>
<dd>
<p>The counterpart to the <code>(*start_test)()</code> call.
It is called on leaving the test.
It needs to be chained to the <code>reporter_finish()</code> to keep track of the breadcrumb book keeping.</p>
</dd>
<dt class="hdlist1"><code>void (*finish_suite)(TestReporter *reporter, const char *file, int line)</code></dt>
<dd>
<p>The counterpart to the <code>(*start_suite)()</code> call called on leaving the test suite, and similar to the <code>(*finish_test)()</code> if your reporter needs a handle on that event too.
The default text reporter chains both this and <code>(*finish_test)()</code> to the same function where it figures out if it is the end of the top level suite.
If so, it prints the familiar summary of passes and fails.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>show_fail()</code> and <code>show_pass()</code> functions are called from the child process, i.e. the isolated process that is <code>fork()</code>:ed to run a single test case.
All others, notably <code>start_&#8230;&#8203;()</code>, <code>finish_&#8230;&#8203;()</code>, <code>show_incomplete()</code> and <code>show_skip()</code> are run in the main (parent) process.
This fact might be important since the processes do not share memory.
Information is passed from the child to the parent using messaging performed within the <code>show_&#8230;&#8203;()</code> functions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The second block is simply resources and book keeping that the reporter can use to liven up the messages&#8230;&#8203;</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>passes</code>
</td>
<td class="hdlist2">
<p>The number of passes so far.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>skips</code>
</td>
<td class="hdlist2">
<p>The number of tests that has been skipped by the <code>xEnsure</code> mechanism (see <a href="#xensure">Skipping Tests</a>)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>failures</code>
</td>
<td class="hdlist2">
<p>The number of failures generated so far.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>exceptions</code>
</td>
<td class="hdlist2">
<p>The number of test functions that have failed to complete so far.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>breadcrumb</code>
</td>
<td class="hdlist2">
<p>This is a pointer to the list of test names in the stack.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>breadcrumb</code> pointer is different and needs a little explanation.
Basically it is a stack, analogous to the breadcrumb trail you see on websites.
Everytime a <code>start()</code> handler is invoked, the name is placed in this stack.
When a <code>finish()</code> message handler is invoked, a name is popped off.</p>
</div>
<div class="paragraph">
<p>There are a bunch of utility functions in <code>cgreen/breadcrumb.h</code> that can read the state of this stack.
Most useful are <code>get_current_from_breadcrumb()</code> which takes the breadcrumb pointer and returns the current test name, and <code>get_breadcrumb_depth()</code> which gives the current depth of the stack.
A depth of zero means that the test run has finished.</p>
</div>
<div class="paragraph">
<p>If you need to traverse all the names in the breadcrumb, then you can call <code>walk_breadcrumb()</code>.
Here is the full signature&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void walk_breadcrumb(Breadcrumb *breadcrumb, void (*walker)(const char *, void *), void *memo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>void (*walker)(const char *, void *)</code> is a callback that will be
passed the name of the test suite for each level of nesting.</p>
</div>
<div class="paragraph">
<p>It is also passed the <code>memo</code> pointer that was passed to the <code>walk_breadcrumb()</code> call.
You can use this pointer for anything you want, as all <strong>Cgreen</strong> does is pass it from call to call.
This is so aggregate information can be kept track of whilst still being reentrant.</p>
</div>
<div class="paragraph">
<p>The last parts of the <code>TestReporter</code> structure are&#8230;&#8203;</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>ipc</code>
</td>
<td class="hdlist2">
<p>This is an internal structure for handling the messaging between reporter and test suite.
You shouldn&#8217;t touch this.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>memo</code>
</td>
<td class="hdlist2">
<p>By contrast, this is a spare pointer for your own expansion.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>options</code>
</td>
<td class="hdlist2">
<p>A pointer to a reporter specific structure that can be used to set options.
E.g. the textreporter defines the structure <code>TextReporterOptions</code> which can be used by calling code to define the use of colors when printing passes and failures.
You set it with <code>set_reporter_options(*void)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_an_example_xml_reporter">9.5. An Example XML Reporter</h3>
<div class="paragraph">
<p>Let&#8217;s make things real with an example.
Suppose we want to send the output from <strong>Cgreen</strong> in XML format, say for storing in a repository or for sending across the network.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>cgreen-runner</code> already has an XML-reporter that you can
use if you need to produce Jenkins/ANT compatible XML output.
See <a href="#runner-options">Cgreen Runner Options</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose also that we have come up with the following format&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml?&gt;
&lt;suite name="Top Level"&gt;
    &lt;suite name="A Group"&gt;
        &lt;test name="a_test_that_passes"&gt;
        &lt;/test&gt;
        &lt;test name="a_test_that_fails"&gt;
            &lt;fail&gt;
                &lt;message&gt;A failure&lt;/message&gt;
                &lt;location file="test_as_xml.c" line="8"/&gt;
            &lt;/fail&gt;
        &lt;/test&gt;
    &lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words a simple nesting of tests with only failures encoded.
The absence of "fail" XML node is a pass.</p>
</div>
<div class="paragraph">
<p>Here is a test script, <code>test_as_xml.c</code> that we can use to construct the
above output&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

Describe(XML_reporter);
BeforeEach(XML_reporter) {}
AfterEach(XML_reporter) {}

Ensure(XML_reporter, reports_a_test_that_passes) {
    assert_that(1 == 1);
}

Ensure(XML_reporter, reports_a_test_that_fails) {
    fail_test("A failure");
}

TestSuite *create_test_group() {
    TestSuite *suite = create_named_test_suite("A Group");
    add_test_with_context(suite, XML_reporter, reports_a_test_that_passes);
    add_test_with_context(suite, XML_reporter, reports_a_test_that_fails);
    return suite;
}

int main(int argc, char **argv) {
    TestSuite *suite = create_named_test_suite("Top Level");
    add_suite(suite, create_test_group());
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can&#8217;t use the auto-discovering <code>cgreen-runner</code> (see <a href="#auto-discovery">Automatic Test Discovery</a>) here since we need to ensure that the nested suites are reported as a nested xml structure.
And we&#8217;re not actually writing real tests, just something that we can use to drive our new reporter.</p>
</div>
<div class="paragraph">
<p>The text reporter is used just to confirm that everything is working.
So far it is.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "Top Level" (2 tests)...
test_as_xml.c:12: Failure: A Group -&gt; reports_a_test_that_fails 
	A failure

  "A Group": 1 pass, 1 failure in 42ms.
Completed "Top Level": 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Our first move is to switch the reporter from text, to our
not yet written XML version&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include "xml_reporter.h"
...

int main(int argc, char **argv) {
    TestSuite *suite = create_named_test_suite("Top Level");
    add_suite(suite, create_test_group());
    return run_test_suite(suite, create_xml_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll start the ball rolling with the <code>xml_reporter.h</code>
header file&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#ifndef _XML_REPORTER_HEADER_
#define _XML_REPORTER_HEADER_

#include &lt;cgreen/reporter.h&gt;

TestReporter *create_xml_reporter();

#endif</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and the simplest possible reporter in <code>xml_reporter.c</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/reporter.h&gt;

#include "xml_reporter.h"

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One that outputs nothing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c test_as_xml.c
$ gcc -c xml_reporter.c
$ gcc xml_reporter.o test_as_xml.o -lcgreen -o xml
$ ./xml</pre>
</div>
</div>
<div class="paragraph">
<p>Yep, nothing.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add the outer XML tags first, so that we can see <strong>Cgreen</strong>
navigating the test suite&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/reporter.h&gt;
#include &lt;cgreen/breadcrumb.h&gt;

#include &lt;stdio.h&gt;
#include "xml_reporter.h"


static void xml_reporter_start_suite(TestReporter *reporter, const char *name, int count) {
    printf("&lt;suite name=\"%s\"&gt;\n", name);
    reporter_start_suite(reporter, name, count);
}

static void xml_reporter_start_test(TestReporter *reporter, const char *name) {
    printf("&lt;test name=\"%s\"&gt;\n", name);
    reporter_start_test(reporter, name);
}

static void xml_reporter_finish_test(TestReporter *reporter, const char *filename, int line, const char *message) {
    reporter_finish_test(reporter, filename, line, message);
    printf("&lt;/test&gt;\n");
}

static void xml_reporter_finish_suite(TestReporter *reporter, const char *filename, int line) {
    reporter_finish_suite(reporter, filename, line);
    printf("&lt;/suite&gt;\n");
}

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although chaining to the underlying <code>reporter_start_*()</code> and <code>reporter_finish_*()</code> functions is optional, I want to make use of some of the facilities later.</p>
</div>
<div class="paragraph">
<p>Our output meanwhile, is making its first tentative steps&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;suite name="Top Level"&gt;
&lt;suite name="A Group"&gt;
&lt;test name="reports_a_test_that_passes"&gt;
&lt;/test&gt;
&lt;test name="reports_a_test_that_fails"&gt;
&lt;/test&gt;
&lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We don&#8217;t require an XML node for passing tests, so the <code>show_fail()</code>
function is all we need&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">...

static void xml_show_fail(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    printf("&lt;fail&gt;\n");
    printf("\t&lt;message&gt;");
    vprintf(message, arguments);
    printf("&lt;/message&gt;\n");
    printf("\t&lt;location file=\"%s\" line=\"%d\"/&gt;\n", file, line);
    printf("&lt;/fail&gt;\n");
...

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;show_fail = &amp;xml_show_fail;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have to use <code>vprintf()</code> to handle the variable argument list passed to us.
This will probably mean including the <code>stdarg.h</code> header as well as <code>stdio.h</code>.</p>
</div>
<div class="paragraph">
<p>This gets us pretty close to what we want&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;suite name="Top Level"&gt;
&lt;suite name="A Group"&gt;
&lt;test name="reports_a_test_that_passes"&gt;
&lt;/test&gt;
&lt;test name="reports_a_test_that_fails"&gt;
&lt;fail&gt;
	&lt;message&gt;A failure&lt;/message&gt;
	&lt;location file="test_as_xml.c" line="15"/&gt;
&lt;/fail&gt;
&lt;/test&gt;
&lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For completeness we should add a tag for a test that doesn&#8217;t complete.
We&#8217;ll output this as a failure, although we don&#8217;t bother with the
location this time&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void xml_show_incomplete(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    printf("&lt;fail&gt;\n");
    printf("\t&lt;message&gt;Failed to complete&lt;/message&gt;\n");
    printf("&lt;/fail&gt;\n");
}
...
TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;show_fail = &amp;xml_show_fail;
    reporter-&gt;show_incomplete = &amp;xml_show_incomplete;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All that&#8217;s left then is the XML declaration and the thorny issue of indenting.
Although the indenting is not strictly necessary, it would make the output a lot more readable.</p>
</div>
<div class="paragraph">
<p>Given that the test depth is kept track of for us with the <code>breadcrumb</code> object in the <code>TestReporter</code> structure, indentation will actually be quite simple.
We&#8217;ll add an <code>indent()</code> function that outputs the correct number of tabs&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void indent(TestReporter *reporter) {
    int depth = get_breadcrumb_depth((CgreenBreadcrumb *)reporter-&gt;breadcrumb);
    while (depth-- &gt; 0) {
        printf("\t");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>get_breadcrumb_depth()</code> function just gives the current test depth as recorded in the reporters breadcrumb (from <code>cgreen/breadcrumb.h</code>).
As that is just the number of tabs to output, the implementation is trivial.</p>
</div>
<div class="paragraph">
<p>We can then use this function in the rest of the code.
Here is the complete listing&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/reporter.h&gt;
#include &lt;cgreen/breadcrumb.h&gt;

#include &lt;stdio.h&gt;
#include "xml_reporter.h"

static void indent(TestReporter *reporter) {
    int depth = get_breadcrumb_depth((CgreenBreadcrumb *)reporter-&gt;breadcrumb);
    while (depth-- &gt; 0) {
        printf("\t");
    }
}

static void xml_reporter_start_suite(TestReporter *reporter, const char *name, int count) {
    if (get_breadcrumb_depth((CgreenBreadcrumb *)reporter-&gt;breadcrumb) == 0) {
        printf("&lt;?xml?&gt;\n");
    }
    indent(reporter);
    printf("&lt;suite name=\"%s\"&gt;\n", name);
    reporter_start_suite(reporter, name, count);
}

static void xml_reporter_start_test(TestReporter *reporter, const char *name) {
    indent(reporter);
    printf("&lt;test name=\"%s\"&gt;\n", name);
    reporter_start_test(reporter, name);
}

static void xml_show_fail(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    indent(reporter);
    printf("&lt;fail&gt;\n");
    indent(reporter);
    printf("\t&lt;message&gt;");
    vprintf(message, arguments);
    printf("&lt;/message&gt;\n");
    indent(reporter);
    printf("\t&lt;location file=\"%s\" line=\"%d\"/&gt;\n", file, line);
    indent(reporter);
    printf("&lt;/fail&gt;\n");
}

static void xml_show_incomplete(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    indent(reporter);
    printf("&lt;fail&gt;\n");
    indent(reporter);
    printf("\t&lt;message&gt;Failed to complete&lt;/message&gt;\n");
    indent(reporter);
    printf("&lt;/fail&gt;\n");
}


static void xml_reporter_finish_test(TestReporter *reporter, const char *filename, int line, const char *message) {
    reporter_finish_test(reporter, filename, line, message);
    indent(reporter);
    printf("&lt;/test&gt;\n");
}

static void xml_reporter_finish_suite(TestReporter *reporter, const char *filename, int line) {
    reporter_finish_suite(reporter, filename, line);
    indent(reporter);
    printf("&lt;/suite&gt;\n");
}

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;show_fail = &amp;xml_show_fail;
    reporter-&gt;show_incomplete = &amp;xml_show_incomplete;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally the desired output&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml?&gt;
&lt;suite name="Top Level"&gt;
	&lt;suite name="A Group"&gt;
		&lt;test name="reports_a_test_that_passes"&gt;
		&lt;/test&gt;
		&lt;test name="reports_a_test_that_fails"&gt;
			&lt;fail&gt;
				&lt;message&gt;A failure&lt;/message&gt;
				&lt;location file="test_as_xml.c" line="15"/&gt;
			&lt;/fail&gt;
		&lt;/test&gt;
	&lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Job done.</p>
</div>
<div class="paragraph">
<p>Possible other reporter customizations include reporters that write to
<code>syslog</code>, talk to IDE plug-ins, paint pretty printed documents or just
return a boolean for monitoring purposes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_usage">10. Advanced Usage</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_custom_constraints">10.1. Custom Constraints</h3>
<div class="paragraph">
<p>Sometimes the built-in constraints that <strong>Cgreen</strong> provide are not sufficient.
With <strong>Cgreen</strong> it is possible to create custom constraints, although you will be depending on some internal structures if you do so.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how to implement a simple example custom constraint that asserts that the value is bigger than 5.
We&#8217;ll implement this using a static constraint since it does not take any parameter.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
static constraints are a bad idea&#8230;&#8203;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First we need the actual compare function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/cgreen.h&gt;

bool compare_want_greater_than_5(Constraint *constraint, CgreenValue actual) {
    return actual.value.integer_value &gt; 5;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then the static constraint structure, for which we&#8217;ll need some of
<strong>Cgreen</strong>'s internal functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/message_formatting.h&gt;
#include "constraint_internal.h"

Constraint static_is_bigger_than_5 = {
        /* .type */ CGREEN_VALUE_COMPARER_CONSTRAINT,
        /* .name */ "be bigger than 5",
        /* .destroy */ destroy_static_constraint,
        /* .compare */ compare_want_greater_than_5,
        /* .test */ test_want,
        /* .format_failure_message_for */ failure_message_for,
        /* .actual_value_message */ "",
        /* .expected_value_message */ "",
        /* .expected_value */ {CGREEN_INTEGER, {5}},
        /* .stored_value_name */ "null",
        /* .parameter_name */ NULL,
        /* .size_of_stored_value */ 0
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This implementation can use a statically declared <code>Constraint</code> structure that is prefilled since it does not need to store the value to be checked.
This static custom constraint can then be used directly in the <code>assert</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(TestConstraint, custom_constraint_using_static_function) {
    Constraint * is_bigger_than_5 = &amp;static_is_bigger_than_5;
    assert_that(10, is_bigger_than_5);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a custom constraint that takes an input parameter, we need to add a function that creates a constraint structure that correctly saves the value to be checked, and, for convenience, a macro.
This time we need to dig into how <strong>Cgreen</strong> stores expected values and we&#8217;ll also make use of <strong>Cgreen</strong>'s utility function <code>string_dup()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;cgreen/message_formatting.h&gt;
#include "cgreen_value_internal.h"
#include "utils.h"


bool compare_want_smaller_value(Constraint *constraint, CgreenValue actual) {
    return actual.value.integer_value &lt; constraint-&gt;expected_value.value.integer_value ;
}

Constraint *create_smaller_than_constraint(intptr_t expected_value, const char *expected_value_name) {
    Constraint *constraint = create_constraint();

    constraint-&gt;expected_value = make_cgreen_integer_value(expected_value);
    constraint-&gt;expected_value_name = string_dup(expected_value_name);
    constraint-&gt;type = CGREEN_VALUE_COMPARER_CONSTRAINT;

    constraint-&gt;compare = &amp;compare_want_smaller_value;
    constraint-&gt;execute = &amp;test_want;
    constraint-&gt;name = "be smaller than";
    constraint-&gt;size_of_expected_value = sizeof(intptr_t);

    return constraint;
}
#define is_smaller_than(value) create_smaller_than_constraint(value, #value)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This gives a custom constraint that can be used in the <code>assert</code> in the
same way as <strong>Cgreen</strong>'s built-in constraints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(TestConstraint, custom_constraint_using_a_function_with_arguments_function) {
    assert_that(9, is_smaller_than(10));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last, and definitely more complex, example is a constraint that takes two structures and compares fields in them.
The constraint will, given a structure representing a piece and another structure representing a box, check if the piece can fit inside the box using a size field.</p>
</div>
<div class="paragraph">
<p>Assuming two "application" structures with <code>size</code> fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct Box {
    int id;
    int size;
} Box;

typedef struct Piece {
    int id;
    int size;
} Piece;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We want to be able to write a test like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(TestConstraint, more_complex_custom_constraint_function) {
    Box box1 = {.id = 1, .size = 5};
    Piece piece99 = {.id = 99, .size = 6};
    assert_that(&amp;piece99, can_fit_in_box(&amp;box1));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement the <code>can_fit_in_box</code> constraint we first need a comparer
function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">bool compare_piece_and_box_size(Constraint *constraint, CgreenValue actual) {
    return ((Piece *)actual.value.pointer_value)-&gt;size
        &lt; ((Box*)constraint-&gt;expected_value.value.pointer_value)-&gt;size ;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And this time we can&#8217;t rely on <strong>Cgreen</strong>'s checker and message generating function <code>test_want()</code> which we used in the previous examples.
So we also need a custom function that calls the comparison and formats a possible error message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void test_fit_piece(Constraint *constraint, const char *function_name, CgreenValue actual,
                           const char *test_file, int test_line, TestReporter *reporter) {
    (*reporter-&gt;assert_true)(
            reporter,
            test_file,
            test_line,
            (*constraint-&gt;compare)(constraint, actual),
            "Piece [%f], does not fit in [%f] in function [%s] parameter [%s]",
            ((Piece *)constraint-&gt;expected_value.value.pointer_value)-&gt;id,
            ((Box *)actual.value.pointer_value)-&gt;id,
            function_name,
            constraint-&gt;parameter_name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally we&#8217;ll use both of those in the constraint creating function
and add the convenience macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Constraint *create_piece_fit_in_box_constraint(intptr_t expected_value, const char *expected_value_name) {
    Constraint *constraint = create_constraint();

    constraint-&gt;expected_value = make_cgreen_pointer_value((void*)expected_value);
    constraint-&gt;expected_value_name = string_dup(expected_value_name);
    constraint-&gt;type = CGREEN_CONTENT_COMPARER_CONSTRAINT;

    constraint-&gt;compare = &amp;compare_piece_and_box_size;
    constraint-&gt;execute = &amp;test_fit_piece;
    constraint-&gt;name = "fit in box";
    constraint-&gt;size_of_expected_value = sizeof(intptr_t);

    return constraint;
}
#define can_fit_in_box(box) create_piece_fit_in_box_constraint((intptr_t)box, #box)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
As stated above, using custom constraints makes your tests vulnurable to changes in <strong>Cgreen</strong>'s internals.
Hopefully a method to avoid this will emerge in the future.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can write custom constraints directly in a test file, but they can of course also be collected into a separately compiled module which is linked with your tests.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hints_and_tips">11. Hints and Tips</h2>
<div class="sectionbody">
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This chapter is intended to contain tips for situations that you might need some help with, but it is nowhere near complete at this time.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="cgreen-mocker">11.1. <code>cgreen-mocker</code> - Automated Mocking</h3>
<div class="paragraph">
<p>Are you starting out with <strong>Cgreen</strong> on a largish legacy system?
And there are loads and loads of functions to mock to get a unit under test?</p>
</div>
<div class="paragraph">
<p>You could try the <code>cgreen-mocker</code> that is supplied as a contributed part of the <strong>Cgreen</strong> source distribution.</p>
</div>
<div class="paragraph">
<p>It is a Python program that parses C language header files and tries to create a corresponding <code>.mock</code> file where each function declaration is replaced with a call to <code>mock()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Usage:
  cgreen-mocker.py &lt;headerfile&gt; { &lt;cpp_directive&gt; }
     &lt;headerfile&gt;: file with function declarations that you want
                   to mock
     &lt;cpp_directive&gt;: any 'cpp' directive but most useful is e.g.
                      "-I &lt;directory&gt;" to ensure cpp finds files.</pre>
</div>
</div>
<div class="paragraph">
<p>So given a header file containing lines like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">extern CgreenValue make_cgreen_integer_value(intptr_t integer);
extern CgreenValue make_cgreen_string_value(const char *string);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cgreen-mocker</code> will, given that there are no errors, print something
like this on the screen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">CgreenValue make_cgreen_integer_value(intptr_t integer) {
  return mock(integer);
}

CgreenValue make_cgreen_string_value(const char *string) {
  return mock(string);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, you would pipe this output to a file.</p>
</div>
<div class="paragraph">
<p>To use <code>cgreen-mocker</code> you need Python, and the following packages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>packaging</code>&#8201;&#8212;&#8201;(<a href="https://github.com/pypa/packaging" class="bare">https://github.com/pypa/packaging</a>)</p>
</li>
<li>
<p><code>pycparser</code>&#8201;&#8212;&#8201;(<a href="https://github.com/eliben/pycparser" class="bare">https://github.com/eliben/pycparser</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These can easily be installed with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ pip install -r requirements.txt</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>cgreen-mocker</code> is an unsupported contribution to the <strong>Cgreen</strong>
project by Thomas Nilefalk.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_compiler_error_messages">11.2. Compiler Error Messages</h3>
<div class="paragraph">
<p>Sometimes you might get cryptic and strange error messages from the compiler.
Since <strong>Cgreen</strong> uses some C/C++ macro magic this can happen and the error messages might not be straight forward to interpret.</p>
</div>
<div class="paragraph">
<p>Here are some examples, but the exact messages differ between compilers and versions.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Compiler error message</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Probable cause&#8230;&#8203;</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"contextFor&lt;X&gt;" is undeclared here</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Missing <code>Describe(&lt;X&gt;);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>undefined reference to 'AfterEach_For_&lt;X&gt;'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Missing <code>AfterEach(&lt;X&gt;)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CgreenSpec<em>&lt;X&gt;</em>&lt;Y&gt;__ is undeclared</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Missing test subject/context in the <code>Ensure</code> of a BDD style test</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>use of undeclared identifier 'contextFor&lt;X&gt;'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Missing <code>Describe(&lt;X&gt;);</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_signed_unsigned_hex_and_byte">11.3. Signed, Unsigned, Hex and Byte</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> attempts to handle primitive type comparisons with a single constraint, <code>is_equal_to()</code>.
This means that it must store the actual and expected values in a form that will accomodate all possible values that primitive types might take, typically an <code>intptr_t</code>.</p>
</div>
<div class="paragraph">
<p>This might sometimes cause unexpected comparisons since all actual values will be cast to match <code>intptr_t</code>, which is a signed value.
E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Char, can_compare_byte) {
  char chars[4] = {0xaa, 0xaa, 0xaa, 0};
  assert_that(chars[0], is_equal_to(0xaa));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On a system which considers <code>char</code> to be signed this will cause the
following <strong>Cgreen</strong> assertion error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>char_tests.c:11: Failure: Char -&gt; can_compare_byte
        Expected [chars[0]] to [equal] [0xaa]
                actual value:                   [-86]
                expected value:                 [170]</pre>
</div>
</div>
<div class="paragraph">
<p>This is caused by the C rules forcing an implicit cast of the <code>signed char</code> to <code>intptr_t</code> by sign-extension.
This might not be what you expected.
The correct solution, by any standard, is to cast the actual value to <code>unsigned char</code> which will then be interpreted correctly.
And the test passes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Casting to <code>unsigned</code> will not always suffice since that is interpreted as <code>unsigned int</code> which will cause a sign-extension from the <code>signed char</code> and might or might not work depending on the size of <code>int</code> on your machine.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to reveal what really happens you might want to see the actual and expected values in hex. This can easily be done with the <code>is_equal_to_hex()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(Char, can_compare_byte) {
  char chars[4] = {0xaa, 0xaa, 0xaa, 0};
  assert_that(chars[0], is_equal_to_hex(0xaa));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This might make the mistake easier to spot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>char_tests.c:11: Failure: Char -&gt; can_compare_byte
        Expected [chars[0]] to [equal] [0xaa]
        actual value:                   [0xfffffffffffffaa]
        expected value:                 [0xaa]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cgreen_and_coverage">11.4. Cgreen and Coverage</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> is compatible with coverage tools, in particular <code>gcov</code>/<code>lcov</code>.
So generating coverage data for your application should be straight forward.</p>
</div>
<div class="paragraph">
<p>This is what you need to do (using <code>gcc</code> or <code>clang</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>compile with <code>-ftest-coverage</code> and <code>-fprofile-arcs</code></p>
</li>
<li>
<p>run tests</p>
</li>
<li>
<p><code>lcov --directory . --capture --output-file coverage.info</code></p>
</li>
<li>
<p><code>genhtml -o coverage coverage.info</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Your coverage data will be available in <code>coverage/index.html</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_garbled_output">11.5. Garbled Output</h3>
<div class="paragraph">
<p>If the output from your <strong>Cgreen</strong> based tests appear garbled or duplicated, this can be caused by the way <strong>Cgreen</strong> terminates its test-running child process.
In many unix-like environments the termination of a child process should be done with <code>_exit()</code>.
However, this interfers severily with the ability to collect coverage data.
As this is important for many of us, <strong>Cgreen</strong> instead terminates its child process with the much cruder <code>exit()</code> (note: no underscore).</p>
</div>
<div class="paragraph">
<p>Under rare circumstances this might have the unwanted effect of output becoming garbled and/or duplicated.</p>
</div>
<div class="paragraph">
<p>If this happens you can change that behaviour using an environment variable <code>CGREEN_CHILD_EXIT_WITH__EXIT</code> (note: two underscores).
If set, <strong>Cgreen</strong> will terminate its test-running child process with the more POSIX-compliant <code>_exit()</code>.
But as mentioned before, this is, at least at this point in time, incompatible with collecting coverage data.</p>
</div>
<div class="paragraph">
<p>So, it&#8217;s coverage <em>or</em> POSIX-correct child exits and guaranteed output consistency.
You can&#8217;t have both&#8230;&#8203;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_legacy_style_assertions">Appendix A: Legacy Style Assertions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cgreen have been around for a while, developed and matured.
There is an older style of assertions that was the initial version, a style that we now call the 'legacy style', because it was more aligned with the original, now older, unit test frameworks.
If you are not interested in historical artifacts, I recommend that you skip this section.</p>
</div>
<div class="paragraph">
<p>But for completeness of documentation, here are the legacy style assertion macros:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_true(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if boolean evaluates true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_false(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fails if boolean evaluates true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_equal(first, second)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if 'first == second'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_not_equal(first, second)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if 'first != second'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_equal(char *, char *)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses 'strcmp()' and passes if
                                          the strings are equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_not_equal(char *, char *)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses 'strcmp()' and fails
                                              if the strings are equal</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Each assertion has a default message comparing the two values.
If you want to substitute your own failure messages, then you must use the <code>*_with_message()</code> counterparts&#8230;&#8203;</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_true_with_message(boolean, message, &#8230;&#8203;)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_false_with_message(boolean, message, &#8230;&#8203;)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_equal_with_message(tried, expected, message, &#8230;&#8203;)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_not_equal_with_message(tried, unexpected, message, &#8230;&#8203;)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_equal_with_message(char *, char *, message, &#8230;&#8203;)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_not_equal_with_message(char *, char *, message, &#8230;&#8203;)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All these assertions have an additional <code>char *</code> message parameter, which is the message you wished to display on failure.
If this is set to <code>NULL</code>, then the default message is shown instead.
The most useful assertion from this group is <code>assert_true_with_message()</code> as you can use that to create your own assertion functions with your own messages.</p>
</div>
<div class="paragraph">
<p>Actually the assertion macros have variable argument lists.
The failure message acts like the template in <code>printf()</code>.
We could change the test above to be&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">Ensure(strlen_of_hello_is_five) {
    const char *greeting = "Hello";
    int length = strlen(greeting);
    assert_equal_with_message(length, 5, "[%s] should be 5, but was %d", greeting, length);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should produce a slightly more user friendly message when things go wrong.
But, actually, Cgreens default messages are so good that you are encouraged to skip the legacy style and go for the more modern constraints style assertions.
This is particularly true when you use the BDD style test notation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
We strongly recommend the use of BDD Style notation with constraints based assertions.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_release_history">Appendix B: Release History</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section only the introduction or changes of major features are listed, and thus only MINOR versions.
For a detailed log of features, enhancements and bug fixes visit the projects repository on GitHub, <a href="https://github.com/cgreen-devs/cgreen" class="bare">https://github.com/cgreen-devs/cgreen</a>.</p>
</div>
<div class="paragraph">
<p>Since 1.4.1 Cgreen has included the following C pre-processer definition variables</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CGREEN_VERSION</code>, a SemVer string</p>
</li>
<li>
<p><code>CGREEN_VERSION_MAJOR</code></p>
</li>
<li>
<p><code>CGREEN_VERSION_MINOR</code></p>
</li>
<li>
<p><code>CGREEN_VERSION_PATCH</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can use them to conditionally check for Cgreen features introduced as declared in the following sections.</p>
</div>
<div class="paragraph">
<p>Since 1.2.0 Cgreen has featured a public version variable in the loaded library, <code>cgreen_library_version</code>.
This is mainly used by the <code>cgreen-runner</code> to present version of the loaded library, but it can also be used to check for availability of features in the same way.</p>
</div>
<div class="sect2">
<h3 id="_1_6_0">B.1. 1.6.0</h3>
<div class="ulist">
<ul>
<li>
<p>Reverted use of <code>libbfd</code> introduced in 1.5.0 due to portability issues and Debian deeming it to be a serious bug due to <code>libbfd</code> not having a stable interface</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_5_1">B.2. 1.5.1</h3>
<div class="ulist">
<ul>
<li>
<p>Fixed a problem with <code>ends_with_string()</code> which randomly crashed</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_5_0">B.3. 1.5.0</h3>
<div class="ulist">
<ul>
<li>
<p>Replaced calling <code>nm</code> with BFD library calls, this makes the <code>cgreen-runner</code> a bit more fiddly to build on some systems</p>
</li>
<li>
<p>Introduced <code>will_capture_parameter()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_4_0">B.4. 1.4.0</h3>
<div class="ulist">
<ul>
<li>
<p>A memory leak in <code>will_return_by_value()</code> was fixed but now requires user deallocation.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_3_0">B.5. 1.3.0</h3>
<div class="ulist">
<ul>
<li>
<p>Renamed CgreenValueType values to avoid clash, now all start with <code>CGREEN_</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_0">B.6. 1.2.0</h3>
<div class="ulist">
<ul>
<li>
<p>Introduced <code>will_return_by_value()</code></p>
</li>
<li>
<p>Introduced <code>with_side_effect()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_1_1_0">B.7. 1.1.0</h3>
<div class="paragraph">
<p>None.</p>
</div>
</div>
<div class="sect2">
<h3 id="_1_0_0">B.8. 1.0.0</h3>
<div class="paragraph">
<p>First official non-beta release.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license">Appendix C: License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright (c) 2006-2021, Cgreen Development Team and contributors<br>
(<a href="https://github.com/cgreen-devs/cgreen/graphs/contributors" class="bare">https://github.com/cgreen-devs/cgreen/graphs/contributors</a>)</p>
</div>
<div class="paragraph">
<p>Permission to use, copy, modify, and/or distribute this software and
its documentation for any purpose with or without fee is hereby
granted, provided that the above copyright notice and this permission
notice appear in all copies, regardless of form, including printed and
compiled.</p>
</div>
<div class="paragraph">
<p>THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_acknowledgements">Appendix D: Acknowledgements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thanks to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Marcus Baker &lt;<a href="mailto:marcus@lastcraft.com">marcus@lastcraft.com</a>&gt; - initiator and substantial inital work</p>
</li>
<li>
<p>Matt Hargett &lt;<a href="mailto:plaztiksyke@gmail.com">plaztiksyke@gmail.com</a>&gt; - upgrading to the modern BDD-ish syntax</p>
</li>
<li>
<p>João Freitas &lt;<a href="mailto:joaohf@gmail.com">joaohf@gmail.com</a>&gt; - asciidoc documentation and Cmake build system</p>
</li>
<li>
<p>Thomas Nilefalk &lt;<a href="mailto:thomas@junovagen.se">thomas@junovagen.se</a>&gt; - cgreen-runner and current maintainer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thanks also go to @gardenia, @d-meiser, @stevemadsenblippar and others for their contributions.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-09-12 20:18:53 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>