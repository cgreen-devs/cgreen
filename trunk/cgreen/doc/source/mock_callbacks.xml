<?xml version="1.0"?>
<page title="Mocking functions in Cgreen" here="mock_callbacks">
    <long_title>
        Creating mock functions in the Cgreen unit testing framework
    </long_title>
    <content>
        <p>
            A good test places the subject under test into a
            tightly controlled environment.
            A test chamber if you like.
            This makes the tests fast, repeatable and reliable.
        </p>
        <p>
            To create a test chamber for testing code, it means we have
            to control any outgoing calls from the code under test.
            We won't believe our test failure if our code is making
            calls to the internet for example.
            Not only that, but it means we have to get dependent components
            working before we can test the higher level code.
            This makes it difficult to code top down.
        </p>
        <p>
            The solution to this dilemma is to write stub code for
            the components whilst the higher level code is written.
            This pollutes the code base with temporary code, and
            the test isolation disappears when the system is eventually
            fleshed out.
        </p>
        <p>
            The ideal is to have minimal stubs written for each
            individual test.
            Cgreen encourages this approach by making such tests
            easier to write.
        </p>
        <section name="problem" title="The problem with streams">
            <p>
                How do we test this code...?
<c><![CDATA[
char *read_paragraph(<strong>int (*read)(void *), void *stream</strong>) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while (<strong>(ch = (*read)(stream)) != EOF</strong>) {
        if (++length > buffer_size) {
            size += 100;
            buffer = realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length] = ch) == '\n') {
            break;
        }
    }
    return buffer;
}
]]></c>
                This is a fairly generic stream filter that turns
                the incoming characters into C string paragraphs, returning
                <code>NULL</code> if there is no paragraph.
                The paragraph has memory allocated to it and the
                stream is advanced ready for the next call.
                That's quite a bit of functionality, and there
                are plenty of nasty boundary conditions.
                I really want this code tested before I deploy it.
            </p>
            <p>
                First we'll test something easy.
                When the stream is empty, nothing should happen.
                We just get <code>NULL</code>s when the stream is
                exhausted.
                This is easy to test if we write our own stream...
<c><![CDATA[
<strong>int empty_stream(void *stream) {
    return EOF;
}</strong>

void reading_lines_from_empty_stream_gives_null() {
    assert_equal(read_paragraph(<strong>&empty_stream, NULL</strong>), NULL);
}

TestSuite *stream_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, reading_lines_from_empty_stream_gives_null);
    return suite;
}
]]></c>
                It's easy, because our fake stream returns only
                one value.
                We don't even need the <code>stream</code> pointer for
                the test, so we just use <code>NULL</code>.
            </p>
            <p>
                Things are harder when the function result changes from
                call to call.
                If we want to test a one character line, we have to send
                the terminating <code>EOF</code> or <code><![CDATA["\n"]]></code>.
                Otherwise our code will loop forever, giving an infinite
                line of just one character.
            </p>
            <p>
                Here is a way we could do this...
<c><![CDATA[
<strong>static int call_count = 0;

int one_character_stream(void *stream) {
    if (call_count++ == 0) {
        return 'a';
    } else {
        return EOF;
    }
}</strong>

void reading_lines_from_one_character_gives_one_character_line() {
    char *line = read_paragraph(<strong>&one_character_stream</strong>, NULL);<strong>
    assert_string_equal("a", line, NULL);</strong>
    free(line);
}
]]></c>
                We simply keep track of the number of calls in the
                callback.
            </p>
            <p>
                There are a bunch of problems with this:
                <ul>
                    <li>It's tedious.</li>
                    <li>It's error prone with many switches</li>
                    <li>We cannot reuse this function in other tests without
                        resetting the counter each time.</li>
                </ul>
                To make our lives much easier, Cgreen includes a sequence
                concept to handle all of the switching for us.
			</p>
		</section>
		<section name="stubbing" title="Stubbing with sequences">
		    <p>
                Here is our callback test rewritten to use Cgreen sequences...
<c><![CDATA[
int one_character_stream(void *stream) {<strong>
    return integer_sequence('a', EOF);</strong>
}

void reading_lines_from_one_character_gives_one_character_line() {
    char *line = read_paragraph(&one_character_stream, NULL);
    assert_string_equal("a", line, NULL);
    free(line);
}
]]></c>
                The <code>integer_sequence()</code> call is a macro that
                does two things:
                <ol>
                    <li>On successive calls it returns each parameter in turn.</li>
                    <li>It resets the counter between tests</li>
                </ol>
                By wrapping this up into a single macro, we make the tests
                more readable.
            </p>
            <p>
                There are only three sequences currently available:
                <table>
                    <tr><th>Sequence</th><th>Return type</th></tr>
                    <tr><td><code>integer_sequence()</code></td><td>integer</td></tr>
                    <tr><td><code>string_sequence()</code></td><td><code>char *</code> pointer</td></tr>
                    <tr><td><code>address_sequence()</code></td><td><code>void *</code> pointer</td></tr>
                </table>
            </p>
            <p>
                Each sequence macro captures the <code>__FILE__</code>
                and <code>__LINE__</code> information where it is called.
                It uses this information to distinguish itself from other
                sequences running in the same test.
                This allows some fairly compact test writing...
<c><![CDATA[
int one_word_stream(void *stream) { return <strong>integer_sequence('t', 'h', 'e', EOF)</strong>; }
int one_word_line(void *stream) { return <strong>integer_sequence('t', 'h', 'e', '\n')</strong>; }
int line_ending_only(void *stream) { return <strong>integer_sequence('\n', EOF)</strong>; }

void test_typical_streams() {
    assert_string_equal("the", read_paragraph(<strong>&one_word_stream</strong>, NULL), NULL);
    assert_string_equal("the", read_paragraph(<strong>&one_word_line</strong>, NULL), NULL);
    assert_string_equal("", read_paragraph(<strong>&line_ending_only</strong>, NULL), NULL);
}
]]></c>
				As each test runs in it's own process, I haven't bothered
				to free the pointers,
				I've just let the operating system do it.
				Purists may want to add the extra code.
			</p>
			<p>
                Even though all the sequences run in the same test, they
                are separate sequences as they are called on separate lines.
                This should be avoided...
<c><![CDATA[
return <strong>integer_sequence(1, 2, 3) + integer_sequence(4, 5, 6)</strong>;
]]></c>
                ...as the sequences will interfere.
                Changing it to...
<c><![CDATA[
return <strong>integer_sequence(1, 2, 3) +
        integer_sequence(4, 5, 6)</strong>;
]]></c>
                ...should be fine.
            </p>
            <p>
                We often call special testing functions &quot;stubs&quot;.
                Cgreen makes it easier to create stubs, and so easier to
                create a sealed test chamber in which to test our code.
                Our fake callback did not need any setting up of files
                or network connections for example, and so we've isolated
                the <code>read_paragraph()</code> code from the rest of the world.
            </p>
            <p>
                The information flow is still one way though, from stub
                to the code under test.
                Things get more interesting when we thing of the traffic
                going the other way.
                This gets us into the same territory as mock objects.
            </p>
        </section>
        <section name="assertions" title="Setting expectations on mock functions">
            <p>
                To swap the traffic flow, we'll look at an outgoing example instead.
                Here is the prewritten production code...
<c><![CDATA[
void by_paragraph(int (*read)(void *), void *in, <strong>void (*write)(char *, void *), void *out</strong>) {
    while (1) {
        char *line = read_paragraph(&read, in);
        if (line == NULL) {
            return;
        }
        <strong>(*write)(line, out);</strong>
        free(line);
    }
}
]]></c>
                This is the start of a formatter utility.
                Later filters will probably break the paragaphs up into justified text,
                but right now that is all abstracted behind the
                <code>void write(char *, void *)</code> interface.
                Our current interests are: does it loop through the paragraphs, and does
                it crash?
            </p>
			<p>
				We could test correct paragraph formation by writing a stub
				that collects the paragraphs into a <code>struct</code>.
				We could then pick apart that <code>struct</code> and test
				each piece with assertions.
				This approach is extremely clumsy in C.
				The language is just not suited to building and tearing down
				complex edifices, never mind navigating them with assertions.
				We would badly clutter our tests.
			</p>
			<p>
				Instead we'll test the output as soon as possible, right in
				the called function...
<c><![CDATA[<strong>
void expect_one_letter_paragraph(char *paragraph, void *stream) {
	assert_string_equal(paragraph, "a", NULL);
}</strong>

void one_character_is_made_into_a_one_letter_paragraph() {
	by_paragraph(
			<strong>&one_character_stream</strong>,
			NULL,
			<strong>&expect_one_letter_paragraph</strong>,
			NULL);
}
]]></c>
				By placing the assertions into the mocked function, we
				keep the tests minimal.
				With a bit of obvious naming, we keep the test clear too.
			</p>
			<p>
				The catch with this method is that if the function
				<code>expect_one_letter_paragraph</code> is never
				called, then no failure will be raised in the tests.
			</p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#iteration">Simulating iterators</a> in tests.
        </link>
    </internal>
    <external>
        <link>
            The <a href="http://sourceforge.net/projects/cgreen">Cgreen SourceForge page</a>.
        </link>
        <link>
            Unit testing was popularised by <a href="http://extremeprogramming.org">eXtreme Programming</a>.
        </link>
    </external>
    <meta>
        <keywords>
        </keywords>
    </meta>
</page>