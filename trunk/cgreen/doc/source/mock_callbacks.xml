<?xml version="1.0"?>
<page title="Mocking callbacks in Cgreen" here="mock_callbacks">
    <long_title>
        Creating mock callbacks in the Cgreen unit testing framework
    </long_title>
    <content>
        <section name="iteration" title="Simulating iterators">
			<p>
				How do we test this code...?
<c><![CDATA[
char *read_line(int (*get_character)(), void *stream) {
	int buffer_size = 0, length = 0;
	char *buffer = NULL;
	int ch;
	while ((ch = (*get_character)(stream)) != EOF) {
		if (++length > size) {
			size += 100;
			buffer = realloc(buffer, size + 1);
		}
		if ((buffer[length] = ch) == '\n') {
			break;
		}
	}
	return buffer;
}
]]></c>
				This is a fairly generic stream reader that turns
				the incoming characters into string lines, returning
				<code>NULL</code> if there is no line.
				The line has memory allocated to it and the
				stream is advanced ready for the next call.
				That's quite a bit of functionality, and there
				are plenty of nasty boundary conditions.
				I really want this code tested before I deploy it.
			</p>
			<p>
				First we'll test something easy.
				When the stream is empty, nothing should happen.
				We just get <code>NULL</code>s when the stream is
				exhausted.
				This is easy to test if we write our own stream...
<c><![CDATA[
int empty_stream(void *stream) {
	return EOF;
}

void reading_lines_from_empty_stream_gives_null() {
	assert_equal(read_line(&empty_stream, NULL), NULL);
}

TestSuite *stream_tests() {
	TestSuite *suite = create_test_suite();
	add_test(suite, reading_lines_from_empty_stream_gives_null);
	return suite;
}
]]></c>
				It's easy, because our fake stream returns only
				one value.
				If we want to test a one character line, we have to send
				the terminating <code>EOF</code> or <code><![CDATA["\n"]]></code>.
				Otherwise our code will loop forever, giving an infinite
				line of just one character.
			</p>
			<p>
				Here is a way we could do this...
<c><![CDATA[
static int call_count = 0;

int one_character_stream(void *stream) {
	if (call_count++ == 0) {
		return 'a';
	} else {
		return EOF;
	}
}

void reading_lines_from_one_character_gives_one_character_line() {
	char *line = read_line(&one_character_stream, NULL);
	assert_string_equal("a", line, NULL);
	free(line);
}
]]></c>
				We simply keep track of the number of calls in the
				callback.
			</p>
			<p>
				There are a bunch of problems with this:
				<ul>
					<li>It's tedious.</li>
					<li>It's error prone with many switches</li>
					<li>We cannot reuse this function in other tests without
						resetting the counter each time.</li>
				</ul>
				To make our lives much easier, Cgreen includes a sequence
				concept to handle all of the switching for us.
			</p>
			<p>
				Here is our callback test rewritten to use Cgreen sequences...
<c><![CDATA[
int one_character_stream(void *stream) {
	return integer_sequence('a', EOF);
}

void reading_lines_from_one_character_gives_one_character_line() {
	char *line = read_line(&one_character_stream, NULL);
	assert_string_equal("a", line, NULL);
	free(line);
}
]]></c>
				The <code>integer_sequence()</code> call is a macro that
				does two things:
				<ol>
					<li>On successive calls it returns each parameter in turn.</li>
					<li>It resets the counter between tests</li>
				</ol>
			</p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#iteration">Simulating iterators</a> in tests.
        </link>
    </internal>
    <external>
        <link>
            The <a href="http://sourceforge.net/projects/cgreen">Cgreen SourceForge page</a>.
        </link>
        <link>
            Unit testing was popularised by <a href="http://extremeprogramming.org">eXtreme Programming</a>.
        </link>
    </external>
    <meta>
        <keywords>
        </keywords>
    </meta>
</page>