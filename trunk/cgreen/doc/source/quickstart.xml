<?xml version="1.0"?>
<page title="Cgreen Quickstart Guide" here="cgreen">
    <long_title>
		Cgreen is a unit testing framework for the C programming language
    </long_title>
    <content>
        <section name="what" title="What is Cgreen?">
            <p>
                Cgreen is a unit tester for the C software developer.
            </p>
			<p>
				Unit testing is a development practice popularised by the
				agile development community.
				It is characterised by writing many small tests alongside
				the normal code.
				Often the tests are written before the code they are testing,
				in a tight test-code-refactor loop.
				Done this way, the practice is known as Test Driven Development.
			</p>
			<p>
				Unit tests are written in the same language as the code, in
				our case C.
				This avoids the mental challenge of constantly switching language,
				and also allows you to use any application code in your tests.
				Cgreen fully supports this style of working.
			</p>
			<p>
				The feature list is:
				<ul>
					<li>Fully composable test suites.</li>
					<li><code>setup()</code> and <code>teardown()</code> for
						tests and test suites.</li>
					<li>Each test runs in it's own process.</li>
					<li>An isolated test can be run in a single process for
						debugging.</li>
					<li>Facilities for the easy mocking of callback functions.</li>
					<li>The reporting mechanism can be easily extended.</li>
				</ul>
			</p>
		</section>
	    <section name="install" title="Installing Cgreen">
			<p>
				Installing Cgreen is as simple as running <em>make</em>
				in the unzipped <em>cgreen folder</em>.
				The makefile will create a unix library called <em>cgreen.a</em>
				which can be used in conjunction with the <em>cgreen.h</em>
				header file to compile test code.
			</p>
			<p>
				We'll first write a test to confirm everything is working.
				Let's start with a simple test script with no tests, called
				<em>first_test.c</em>...
<c><strong>
#include "cgreen/cgreen.h"</strong>

int main(int argc, char **argv) {<strong>
    TestSuite *suite = create_test_suite();
    return run_test_suite(suite, create_text_reporter());</strong>
}
</c>
				This is a very unexciting test.
				It just creates an empty test suite and runs it.
				It's usually easier to proceed in small steps, though,
				and this is the smallest one I could think of.
				The only complication is the <em>cgreen.h</em> header
				file.
				Here I am assuming we have symlinked the Cgreen folder
				into the same location as our test script, or placed
				the Cgreen folder in the path.
			</p>
			<p>
				Building this test is, of course, trivial...
<sh>
gcc -c first_test.c
gcc first_test.o cgreen/cgreen.a -o first_test
./first_test
</sh>
				Invoking the executable should give...
<sh>
Running "first_test.c"...
Completed "first_test.c": 0 passes, 0 failures, 0 exceptions.
</sh>
				All of the above rather assumes you are working in a
				Unix like environment, probably with <em>gcc</em>.
				This has been tested on Linux and Mac OSX so far, but
				not Windows.
				It might work though.
				Cgreen should compile on all systems the support the
				<em>sys/msg.h</em> messaging library.
			</p>
			<p>
				So far we have tested compilation, and that the test suite
				actually runs.
				Let's add a meaningless test or two...
<c>
#include "cgreen/cgreen.h"
<strong>
void this_test_should_pass() {
	assert_true(1, "This should be true");
}

void this_test_should_fail() {
	assert_true(0, "This should be false");
}
</strong>
int main(int argc, char **argv) {
	TestSuite *suite = create_test_suite();<strong>
	add_unit_test(suite, this_test_should_pass);
	add_unit_test(suite, this_test_should_fail);</strong>
	return run_test_suite(suite, create_text_reporter());
}
</c>
				A test can be any function with a <code>void (void)</code>
				signature.
				<code>add_unit_test()</code> is a macro, hence
				there is no <code>&amp;</code> with the function
				pointer.
			</p>
			<p>
				On compiling and running, we now get the output...
<sh>
Running "first_test.c"...
Failure!: this_test_should_fail -> This should be false at [first_test.c] line [8]
Completed "first_test.c": 1 pass, 1 failure, 0 exceptions.
</sh>
				The <code>TextReporter</code>, created by the
				<code>create_text_reporter()</code> call, is the
				simplest way to output the test results.
				It just streams the failures as text.
				Currently it's the only method supported.
			</p>
		</section>
	    <section name="typical" title="A more typical test case">
			<p>
				For a more realistic example we need something to test.
				We'll pretend that we are writing a function to copy
				the first word of a sentence.
				Not an obviously useful function, but we'll be using it
				for something more practical below.
				Here is an example of what we have in mind...
<c><![CDATA[
first = first_word("Just the first");
]]></c>
				This time we'll add a little more structure to our tests.
				Rather than having the test as a stand alone program, we'll
				separate the runner from the test cases.
				That way, multiple test suites of test cases can be
				included in the <code>main()</code> runner.
			</p>
			<p>
				Here is the so far empty test case in <em>words_test.c</em>...
<c><![CDATA[
#include "cgreen/cgreen.h"
<strong>
TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    return suite;
}</strong>
]]></c>
				Here is the <em>all_tests.c</em> test runner...
<c><![CDATA[
#include "cgreen/cgreen.h"

TestSuite *words_tests();

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();<strong>
    add_suite(suite, words_tests());</strong>
    if (argc > 1) {<strong>
        return run_single_test(suite, argv[1], create_text_reporter());</strong>
    }
    return run_test_suite(suite, create_text_reporter());
}
]]></c>
				Cgreen has two ways of running tests.
				The default is with each test run in it's own process.
				This is what happens if you invoke <code>run_test_suite()</code>.
				While this makes all the tests independent, the constant
				<code>fork()</code>'ing can make the tests difficult to debug.
				To make debugging simpler, Cgreen does not <code>fork()</code>
				when only a single test is run.
			</p>
			<p>
				Building this scaffolding...
<sh>
gcc -c words_test.c
gcc -c all_tests.c
gcc words_test.o all_tests.o cgreen/cgreen.a -o all_tests
</sh>
				...and executing the result gives the familiar...
<sh>
Running "all_tests.c"...
Completed "all_tests.c": 0 passes, 0 failures, 0 exceptions.
</sh>
				All this scaffolding is pure overhead, but from now on adding tests
				will be a lot easier.
				Here is a first test of <code>first_word()</code>...
<c><![CDATA[
#include "cgreen/cgreen.h"<strong>
#include "words.h"</strong>

void can_duplicate_first_word() {
	char *word = first_word("Birds of a feather");<strong>
	assert_string_equal(word, "Birds", "First word was [%s]", word);</strong>
	free(word);
}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
	add_unit_test(suite, <strong>can_duplicate_first_word</strong>);
    return suite;
}
]]></c>
				
			</p>
            <p>
                <a href="http://sourceforge.net/projects/cgreen/"><img src="http://sourceforge.net/sflogo.php?group_id=130951&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo"/></a>
            </p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#what">What is Cgreen?</a>
        </link>
        <link>
            <a href="#install">Installing</a> and testing the installation.
        </link>
        <link>
            A <a href="#typical">more typical Cgreen test case</a>.
        </link>
        <link>
            Simulating interactions with <a href="#mock">mock function callbacks</a>.
        </link>
    </internal>
    <external>
        <link>
            The <a href="http://sourceforge.net/projects/cgreen">Cgreen SourceForge page</a>.
        </link>
    </external>
    <meta>
        <keywords>
        </keywords>
    </meta>
</page>