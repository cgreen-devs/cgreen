<?xml version="1.0"?>
<page title="Cgreen guia rápido" here="Cgreen">
    <long_title>
        Cgreen é um framework para testes de unidade na linguagem de programação C
    </long_title>
    <content>
        <section name="what" title="O que é Cgreen?">
            <p>
                Cgreen é um testador de código unitário para desenvolvimento
                software na linguagem C.                
                Ou seja é uma ferramenta de automação de teste e garantia de 
                qualidade de software para times de desenvolvimento.
                A ferramenta é completamenta open source e publicada sob a 
                <a href="http://www.gnu.org/licenses/lgpl.html">LGPL</a>.
            </p>
            <p>
                Testes unitários é uma prática de desenvolvimento popularizada
                pela comunidade de desenvolvimento ágil.
                É caracterizada pela escrita de muitos pequenos testes ao longo
                do código fonte normal.
                Frequentemente os testes são escritos antes do código que será
                testado, em um rigoroso loop de teste e refatoração de código.
                Feito deste modo, é uma prática conhecida como Desenvolvimento
                Dirigido ao Teste (Test Driven Development TDD).
                Cgreen suporta este estilo de trabalho.
            </p>
            <p>
                Testes de unidade são escritos na mesma linguagem que o código,
                no nosso caso C.
                Isto evita confusão pela constante troca de linguagem, e também
                permite utilizar qualquer parte do código nos seus testes.
            </p>
            <p>
                A lista de recuros é:
                <ul>
                    <li>Suite de Testes totalmente combináveis.</li>
                    <li><code>setup()</code> e <code>teardown()</code> para
                        testes e suite de teste.</li>
                    <li>Cada teste é executado por seu próprio processo.</li>
                    <li>Um teste isolado pode ser executado em um único processo
                        para debug.</li>
                    <li>Abilidade para criar funções mock.</li>
                    <li>O mecanismo de relatório pode ser facilmente extendido.</li>
                </ul>
                Esta ferramenta é para programação em C, não para C++.
            </p>
        </section>
        <section name="install" title="Instalando o Cgreen">
            <p>
                Instalar o Cgreen é simples, basta executar <a href="http://www.gnu.org/software/make/">make</a>
                no diretório <em>cgreen</em> descompactado. 
                O arquivo makefile irá criar uma biblioteca unix chamada de 
                <em>cgreen.a</em> no qual pode ser utilizada em conjunto com o 
                arquivo de cabeçalho <em>cgreen.h</em> para compilar o código de
                testes.                
            </p>
            <p>
                Primeiro vamos escrever um teste para confirmar que tudo está 
                funcionando.
                Vamos começar com um simples script de teste não testado, chamado 
                <em>first_test.c</em>
<c><![CDATA[<strong>
#include "cgreen/cgreen.h"</strong>

int main(int argc, char **argv) {<strong>
    TestSuite *suite = create_test_suite();
    return run_test_suite(suite, create_text_reporter());</strong>
}
]]></c>
                Isto é um teste muito sem graça.
                Somente cria uma suite de teste vazia e executa.
                Geralmente é mais fácil avançar em pequenos passos, porém,
                isso é o mais pequeno eu poderia pensar.
                A única complicação é o arquivo de cabeçalho <em>cgreen.h</em>.
                Aqui estou assumindo que nós temos um link simbólico com o diretório
                do Cgreen no mesmo lugar dos nossos scripts de testes, ou colocando
                o diretório Cgreen no seu path.
            </p>
            <p>
            	Fazer um build desse teste, com certeza, é algo trivial...
<sh>
gcc -c first_test.c
gcc first_test.o cgreen/cgreen.a -o first_test
./first_test
</sh>
                Invocando o executável teremos...
<sh>
Running "main"...
Completed "main": 0 passes, 0 failures, 0 exceptions.
</sh>
                Tudo anteriormente assume que você está trabalhando em um ambiente
                tipo Unix, provavelmente com o compilador <em>gcc</em>.
                O código é bastante aderente ao C99, de modo que qualquer compilador C
                deve funcionar.
                Cgreen pode ser compilador em todos os sistemas que suportam a 
                biblioteca de mensagens <em>sys/msg.h</em>.
                Foi testado em Linux e Mac OSX, mas não no Windows, apesar que 
                pode trabalhar também.
            </p>
            <p>
                Até agora, temos ensaiado a compilação, em que a suite de teste é
                executada.
                Vamos acrescentar um ou dois ensaios sem sentido, para que você
                possa ver como isto ocorre...
<c><![CDATA[
#include "cgreen/cgreen.h"
<strong>
void this_test_should_pass() {
    assert_true(1);
}

void this_test_should_fail() {
    assert_true(0);
}
</strong>
int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();<strong>
    add_test(suite, this_test_should_pass);
    add_test(suite, this_test_should_fail);</strong>
    return run_test_suite(suite, create_text_reporter());
}
]]></c>
                Um teste pode ser qualquer função com a assinatura <code>void (void)</code>
                <code>add_test()</code> é uma macro, então
                não há <code>&amp;</code> com o ponteiro para a função.
            </p>
            <p>
            	Compilando e executando, teremos o resultado...                
<sh><![CDATA[
Running "main"...
Failure!: this_test_should_fail -> Problem at [first_test.c] line [8]
Completed "main": 1 pass, 1 failure, 0 exceptions.
]]></sh>
                O <code>TextReporter</code>, criado pela chamada
                <code>create_text_reporter()</code>, é o jeito simples para
                imprimir o resultado dos testes.
                Ele somente envia os testes com falha.
                Atualmente ele é o único método suportado.
            </p>
        </section>
        <section name="tdd" title="Five minutes doing TDD with Cgreen">
            <p>
                Para um exemplo mais real precisamos de algo para testar.
                Nós pretendemos escrever uma função que separe as palavras
                de uma sentença.
                Ela faz isso substituindo quaisquer espaços com terminadores
                de palavras e retornando o número de conversões mais um.
                Aqui está um exemplo do que temos em mente...
<c><![CDATA[
char *sentence = strdup("Just the first test");
word_count = split_words(sentence);
]]></c>
                <code>sentence</code> pode agora apontar para
                <code><![CDATA["Just\0the\0first\0test"]]></code>.
                Não é obviamente uma função muito útil, mas usaremos 
                isso para algo mais prático em breve.
            </p>
            <p>
                Desta vez nós adicionaremos um pouco mais de estrutura em nossos testes.
                Em vez de termos os testes em um programa único, nós separaremos
                o principal dos de casos de teste.
                Desta forma, vários suites de teste dos casos de teste podem ser
                incluídos no <code>main()</code> do arquivo principal.
                Isto nos dará menos trabalho para adicionar mais testes.
            </p>
            <p>
                Aqui está o, até agora vazio, caso de teste em <em>words_test.c</em>...
<c><![CDATA[
#include "cgreen/cgreen.h"
<strong>
TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    return suite;
}</strong>
]]></c>
                Aqui está o <em>all_tests.c</em> teste principal...
<c><![CDATA[
#include "cgreen/cgreen.h"

TestSuite *words_tests();

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();<strong>
    add_suite(suite, words_tests());</strong>
    if (argc > 1) {<strong>
        return run_single_test(suite, argv[1], create_text_reporter());</strong>
    }
    return run_test_suite(suite, create_text_reporter());
}
]]></c>
                Cgreen possui dois jeitos de executar os testes.
                O padrão é cada teste ser executado dentro do seu próprio processo.
                Isto é oque acontece se você invoca <code>run_test_suite()</code>.
                Enquanto isto faz todos os testes independentes, a constante <code>fork()</code>
                pode complicar o debug.
                Para deixar o debug simples, Cgreen não faz <code>fork()</code> 
                quando um único teste é executado pelo nome com <code>run_single_test()</code>. 
            </p>
            <p>
                Building este suporte...
<sh>
gcc -c words_test.c
gcc -c all_tests.c
gcc words_test.o all_tests.o cgreen/cgreen.a -o all_tests
</sh>
                ...e executando temos o resultado...                
<sh><![CDATA[
Running "main"...
Completed "main": 0 passes, 0 failures, 0 exceptions.
]]></sh>
                Todo este suporte (scaffolding) é puro adendo, mas a partir de agora adicionar 
                novos testes irá ser muito fácil.
            </p>
            <p>
                Aqui está um primeiro teste de <code>split_words()</code>...
<c><![CDATA[
#include "cgreen/cgreen.h"<strong>
#include "words.h"
#include <string.h>

void word_count_returned_from_split() {
    char *sentence = strdup("Birds of a feather");
    int word_count = split_words(sentence);
    assert_equal(word_count, 4);
    free(sentence);
}</strong>

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();<strong>
    add_test(suite, word_count_returned_from_split);</strong>
    return suite;
}
]]></c>
                A macro <code>assert_equal()</code> recebe dois valores para comparar.
                Como padrão as mensagens são enviadas para <code>STDOUT</code> pelo 
                <code>TextReporter</code>. 
            </p>
            <p>
                Para compilar isso precisamos criar o arquivo de cabeçalho
                <em>words.h</em>...
<c>
int split_words(char *sentence);
</c>
		...e para linkar o código nós precisamos de uma pequena função em 
                <em>words.c</em>...
<c>
int split_words(char *sentence) {
    return 0;
}
</c>
    		Um build completo mais adiante...
<sh>
gcc -c all_tests.c
gcc -c words_test.c
gcc -c words.c
gcc all_tests.o words_test.o words.o cgreen/cgreen.a -o all_tests
./all_tests
</sh>
                ...e nós temos uma resposta mais útil...
<sh><![CDATA[
Running "main"...
Failure!: words_tests -> word_count_returned_from_split ->
        [0] should match [4] at [words_test.c] line [8]
Completed "main": 0 passes, 1 failure, 0 exceptions.
]]></sh>
                O "segredo" é o encapsulamento dos testes.
                Isto vem da suite de teste, no qual podem ser encapsulados um 
                no outro, através da função de teste, e finalmente a mensagem vinda
                de uma afirmação (assertion).
                Na linguagem do Cgreen, uma falha é uma afirmação inadequada,
                uma excessão é acumulada quando um teste falha por alguma razão.
            </p>
            <p>
                Nós podemos fazer isto passar apenas retornando o valor 4.
                Fazendo TDD realmente em pequenos passos, você fazeria isso, 
                mas francamente este exemplo é muito simples.
                Em vez disso nós vamos ir direto para a refatoração... 
<c><![CDATA[
<strong>#include <string.h></strong>

int split_words(char *sentence) {<strong>
    int i, count = 1;
    for (i = 0; i < strlen(sentence); i++) {
        if (sentence[i] == ' ') {
            count++;
        }
    }
    return count;</strong>
}
]]></c>
		Existe um problema escondido aqui, mas nossos testes passarão
		então fingiremos que não fomos avisados..
            </p>
            <p>
                Hora de adicionar um novo teste.
                Queremos confirmar que a string está quebrada em palavras
                separadas...
<c><![CDATA[
#include "cgreen/cgreen.h"
#include "words.h"
#include <string.h>

void word_count_returned_from_split() { ... }
<strong>
void spaces_should_be_converted_to_zeroes() {
    char *sentence = strdup("Birds of a feather");
    split_words(sentence);
    int comparison = memcmp("Birds\0of\0a\0feather", sentence, strlen(sentence));
    assert_equal(comparison, 0);
    free(sentence); 
}</strong>

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, word_count_returned_from_split);<strong>
    add_test(suite, spaces_should_be_converted_to_zeroes);</strong>
    return suite;
}
]]></c>
                Com certeza, nós temos uma falha...
<sh><![CDATA[
Running "main"...
Failure!: words_tests -> spaces_should_be_converted_to_zeroes ->
        [-32] should match [0] at [words_test.c] line [16]
Completed "main": 1 pass, 1 failure, 0 exceptions.
]]></sh>
                Nada demais contando que ainda não escrevemos o código.
            </p>
            <p>
                A solução...
<c><![CDATA[
int split_words(char *sentence) {
    int i, count = 1;
    for (i = 0; i < strlen(sentence); i++) {
        if (sentence[i] == ' ') {<strong>
            sentence[i] = '\0';</strong>
            count++;
        }
    }
    return count;
}
]]></c>
                ...revela nossa suspeita anterior...
<sh><![CDATA[
Running "main"...
Failure!: words_tests -> word_count_returned_from_split ->
        [2] should match [4] at [words_test.c] line [8]
Completed "main": 1 pass, 1 failure, 0 exceptions.
]]></sh>
                Nosso teste anterior falhou agora, porque modificamos a chamada
                <code>strlen()</code> no nosso loop.
                Movendo o cálculo do tamanho para fora do loop...                
<c><![CDATA[
int split_words(char *sentence) {
    int i, count = 1, <strong>length = strlen(sentence)</strong>;
    for (i = 0; <strong>i < length</strong>; i++) {
        ...
    }
    return count;
}
]]></c>
                ...restaurando a ordem...
<sh>
Running "main"...
Completed "main": 2 passes, 0 failures, 0 exceptions.
</sh>
                É bom manter o código sob controle enquanto estamos escrevendo
                efetivamente, e debugar depois quando as coisas se tornarem mais
                complicadas.
            </p>
            <p>
                Isso vai ser melhorado mais em frente.
                Vamos fazer algo mais interessante.               
            </p>
        </section>
        <section name="mock" title="What are mock functions?">
            <p>
            	O próximo exemplo é mais realista.
                Ainda no nosso arquivo <em>words.h</em>, queremos escrever
                uma função que invoque uma callback em cada palavra na sentença.
                Algo como...
<c><![CDATA[
void act_on_word(const char *word, void *memo) { ... }<strong>
words("This is a sentence", &act_on_word, &memo);</strong>
]]></c>
                Aqui o ponteiro <code>memo</code> é apenas algum dado acumulado
                que a callback <code>act_on_word()</code> está trabalhando.
                Outras pessoas escreverão a função <code>act_on_world()</code> 
                e provavelmente muitas outras iguais a esta.
                A callback é na verdade um ponto flexível, e não é de interesse
                agora.
            </p>
            <p>
                A função em teste é a <code>words()</code> e nós queremos ter 
                certeza que ela caminhe na sentença corretamente, enviando palavras
                individuais como esta.
                Como testar isso?
            </p>
            <p>
                Vamos começar com uma palavra.
                Neste caso nós esperaríamos a callback ser invocada uma única vez
                com a única palavra, certo?
                Aqui está o teste para isso...
<c><![CDATA[
...
#include <stdlib.h>
...<strong>
void mocked_callback(const char *word, void *memo) {
    mock(word, memo);
}

void single_word_sentence_invokes_callback_once() {
    expect(mocked_callback, want_string(word, "Word"), want(memo, NULL));
    words("Word", &mocked_callback, NULL);
}</strong>

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    ...
    add_test(suite, <strong>single_word_sentence_invokes_callback_once</strong>);
    return suite;
}
]]></c>
                Qual é a graça olhando para a função <code>mock()</code>?
            </p>
            <p>
                Uma mock é basicamente um objeto programável.
                Em C objetos são limitados a funções, então isto é a função mock.
                A macro <code>mock()</code> compara os parâmetros que estão chegando
                com os valores esperados e envia mensagens para o suite de teste
                se há alguma falha.
                Ela também retorna quaisquer valores que tenham sido pré-programados
                no teste.
            </p>
            <p>
                A função teste é <code>single_word_sentence_invokes_callback_once()</code>.
                Usando a macro <code>expect()</code> ela programa a função mock 
                para esperar uma simples chamada.
                Esta chamada terá parâmetros <code><![CDATA["Word"]]></code> e
                <code>NULL</code>.
                Se eles não forem iguais depois, nós teremos um teste com falha.
            </p>
            <p>
                Somente o método do teste, não a callback mock, é adicionado ao
                suite de teste.
            </p>
            <p>
                Para uma compilação e linkagem com sucesso, o arquivo <em>words.h</em>
                deve agora parecer como...
<c><![CDATA[
int split_words(char *sentence);<strong>
void words(const char *sentence, void (*walker)(const char *, void *), void *memo);</strong>
]]></c>
                ...e o arquivo <em>words.c</em> pode ter o trecho...
<c><![CDATA[<strong>
void words(const char *sentence, void (*walker)(const char *, void *), void *memo) {
}</strong>
]]></c>
		Isso mostra-nos as falhas esperadas nos testes.. 
<sh><![CDATA[
Running "main"...
Failure!: words_tests -> single_word_sentence_invokes_callback_once ->
        Call was not made to function [mocked_callback] at [words_test.c] line [25]
Completed "main": 2 passes, 1 failure, 0 exceptions.
]]></sh>
		CGreen avisa que a callback nunca foi utilizada.
                Cgreen reports that the callback was never invoked.
                Nos podemos facilmente passar o teste preenchendo a implementação
                com...
<c><![CDATA[
void words(const char *sentence, void (*walker)(const char *, void *), void *memo) {
    <strong>(*walker)(sentence, memo);</strong>
}
]]></c>
		Isto é, nós somente invocamos isso uma vez com toda a string.
                Este é uma medição temporária que nos ajudará a continuar.
                Agora qualquer coisa pode passar, ainda que isto não esteja muito 
                testado ainda.
            </p>
            <p>
                Isso foi tudo convencional, mas vamos abordar o caso de separação
                da sentença.
                Aqui a função de teste será adicionada em <em>words_test.c</em>...
<c><![CDATA[
void phrase_invokes_callback_for_each_word() {<strong>
    expect(mocked_callback, want_string(word, "Birds"));
    expect(mocked_callback, want_string(word, "of"));
    expect(mocked_callback, want_string(word, "a"));
    expect(mocked_callback, want_string(word, "feather"));</strong>
    words(<strong>"Birds of a feather"</strong>, &mocked_callback, NULL);
}
]]></c>
		Cada chamada é esperada em sequẽncia.
                Todas as falhas, ou sem chamadas, ou extra chamadas, e podemos
                vê-las.
                Podemos ver tudo isso quando rodamos os testes...
<sh><![CDATA[
Running "main"...
Failure!: words_tests -> phrase_invokes_callback_for_each_word ->
        Wanted [Birds], but got [Birds of a feather] in function [mocked_callback] parameter [word] at [words_test.c] line [30]
Failure!: words_tests -> phrase_invokes_callback_for_each_word ->
        Call was not made to function [mocked_callback] at [words_test.c] line [31]
Failure!: words_tests -> phrase_invokes_callback_for_each_word ->
        Call was not made to function [mocked_callback] at [words_test.c] line [32]
Failure!: words_tests -> phrase_invokes_callback_for_each_word ->
        Call was not made to function [mocked_callback] at [words_test.c] line [33]
Completed "main": 4 passes, 4 failures, 0 exceptions.
]]></sh>
                A primeira falha conta a história.
                Nossa pequena função <code>words()</code> chamou a callback mock 
                com toda a sequência.
                Isto faz sentido, porque aquela era o jeito para pegar o 
                próximo teste.
            </p>
            <p>
                Embora não seja relevante neste guia, eu não posso resistir em pegar
                esses tester para passar.
                Além disso, nós fizemos uso da função que nós criamos anteriormente...
<c><![CDATA[
void words(const char *sentence, void (*walker)(const char *, void *), void *memo) {<strong>
    char *words = strdup(sentence);
    int word_count = split_words(words);
    char *word = words;
    while (word_count-- > 0) {
        (*walker)(word, memo);
        word = word + strlen(word) + 1;
    }
    free(words);</strong>
}
]]></c>
		E com esse trabalho somos recompensados com...
<sh><![CDATA[
Running "main"...
Completed "main": 8 passes, 0 failures, 0 exceptions.
]]></sh>
                Mais trabalho do que eu gostaria de admitir, mas isso me pegou
                três vezes para funcionar.
                Primeiramente esqueci-me o <code>+ 1</code> adicionado no <code>strlen()</code>,
                então esqueci de trocar <code>sentence</code> para <code>word</code>
                na chamada <code>(*walker)()</code>, e finalmente a terceira vez foi sorte.
                É claro rodando os testes cada vez que eram feitos esses erros 
                muito óbvios.
                Gastei mais tempo para escrever esses parágrafos do que para 
                escrever o código.
            </p>
            <p>
                <a href="http://sourceforge.net/projects/cgreen/"><img src="http://sourceforge.net/sflogo.php?group_id=130951&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo"/></a>
            </p>
        </section>
    </content>
    <internal>
        <link>
            O que é o <a href="#what">testador unitário Cgreen</a>?
        </link>
        <link>
            <a href="#install">Instalando o Cgreen</a> e testando a instalação.
        </link>
        <link>
            <a href="#tdd">Exemplo de Test driven development</a> com Cgreen em 5 minutos.
        </link>
        <link>
            Testes interativos com <a href="#mock">funções mock</a>.
        </link>
    </internal>
    <external>
        <link>
            A <a href="http://sourceforge.net/projects/cgreen">página do Cgreen no SourceForge</a>.
        </link>
        <link>
            Testes de unitários foi popularisado pela <a href="http://extremeprogramming.org/">eXtreme Programming</a>.
        </link>
        <link>
            Cgreen é estremamente influenciado pela ferramenta de teste unitário <a href="http://check.sourceforge.net/">Check</a>.
        </link>
    </external>
    <meta>
        <keywords>
            teste de código, testar-primeiro, testar primeiro, qualidade códifo, automatizar teste de código,
            teste automático, programação c, ferramentas c, teste de código c, teste de código em c,
            checagem e teste de codigo, mocking functions, mocks em c, teste de cobertura,
            tdd in c, teste de regressão em c, cunit, cppunit, c unit testing frameworks,
            open source, open source framework, gnu licence, lgpl, free software, qualidade de código,
            teste protegido
        </keywords>
    </meta>
</page>