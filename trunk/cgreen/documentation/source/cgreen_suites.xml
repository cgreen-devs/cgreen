<?xml version="1.0"?>
<page title="Writing Cgreen test suites" here="cgreen">
    <long_title>
        Creating C test suites using the Cgreen unit testing framework
    </long_title>
    <content>
        <p>
            Cgreen is a tool for building unit tests in the C language,
            usually alongside writing the production code.
            These tests are written by the programmer to prevent bugs,
            rather than by the customer or eventual user of the software.
            Even though the test suites are created by software developers,
            they are intended to be human readable C code.
        </p>
        <section name="writing" title="Writing basic tests">
            <p>
                Cgreen tests are simply C functions with no parameters
                and a <code>void</code> return value.
                An example might be...
<c><![CDATA[
static void <strong>strlen_of_hello_should_be_five</strong>() {
    <strong>assert_equal</strong>(strlen("Hello"), 5, NULL);
}
]]></c>
                The test function name can be anything you want.
                The <code>assert_equal()</code> call is an example
                of an assertion.
                Assertions send messages to Cgreen, which in turn
                outputs the results.
            </p>
            <p>
                Here are the standard assertions...
                <table>
                    <tr><th>Assertion</th><th>Description</th></tr>
                    <tr><td><code>assert_true(boolean)</code></td><td>Passes if boolean evaluates true</td></tr>
                    <tr><td><code>assert_false(boolean)</code></td><td>Fails if boolean evaluates true</td></tr>
                    <tr><td><code>assert_equal(first, second)</code></td><td>Passes if <code>first == second</code></td></tr>
                    <tr><td><code>assert_not_equal(first, second)</code></td><td>Passes if <code>first != second</code></td></tr>
                    <tr><td><code>assert_string_equal(char *, char *)</code></td><td>Uses <code>strcmp()</code> and passes if the strings are equal</td></tr>
                    <tr><td><code>assert_string_not_equal(char *, char *)</code></td><td>Uses <code>strcmp()</code> and fails if the strings are equal</td></tr>
                </table>
                All the assertions have an addition <code>char *</code> parameter
                which is the message you wished to display on failure.
                If set to <code>NULL</code> then a not very helpful default
                message is shown instead.
            </p>
            <p>
                Actually the assertion macros have variable argument lists as
                the failure message acts like the template in <code>printf()</code>.
                We could change the test above to be...
<c><![CDATA[
static void strlen_of_hello_should_be_five() {
    int length = strlen("Hello");
    assert_equal(length, 5, <strong>"Should be 5, but was %d"</strong>, length);
}
]]></c>
                A much more user friendly message when things go wrong.
            </p>
            <p>
                For this test to work there needs to be a running test suite.
                We can create one expecially for this test like so...
<c><![CDATA[
<strong>TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, strlen_of_hello_should_be_five);
    return suite;
}</strong>
]]></c>
                In case you have spotted that <code>strlen_of_hello_should_be_five()</code>
                should have an ampersand in front of it, <code>add_test()</code>
                is a macro.
                The <code>&amp;</code> is added automatically.
            </p>
            <p>
                To run the test suite, we call <code>run_test_suite()</code> on
                it.
                This function cleans up the test suite after running it, so
                we can just write...
<c><![CDATA[
<strong>run_test_suite(our_tests(), create_text_reporter());</strong>
]]></c>
                The results of assertions are ultimately delivered as passes and
                failures to a collection of callbacks defined in a
                <code>TestReporter</code> structure.
                The only predefined one in Cgreen is the <code>TextReporter</code>
                that delivers messages in plain text.
            </p>
            <p>
                The full test script now looks like...
<c><![CDATA[
<strong>#include "cgreen/cgreen.h"
#include <string.h></strong>

static void strlen_of_hello_should_be_five() {
    int length = strlen("Hello");
    assert_equal(length, 5, "Should be 5, but was %d", length);
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, strlen_of_hello_should_be_five);
    return suite;
}

<strong>int main(int argc, char **argv) {
    return </strong>run_test_suite(our_tests(), create_text_reporter());<strong>
}</strong>
]]></c>
                The return value of <code>run_test_suite()</code> is a
                Unix exit code.
            </p>
            <p>
                Compliling and running gives...
<sh><![CDATA[
gcc -c strlen_test.c
gcc strlen_test.o cgreen/cgreen.a -o strlen_test
./strlen_test<strong>
Running "strlen_test.c"...
Completed "strlen_test.c": 1 pass, 0 failures, 0 exceptions.</strong>
]]></sh>
                The test messages are only shown on failure.
                If we break our test...
<c><![CDATA[
static void strlen_of_hello_should_be_five() {
    int length = strlen(<strong>"Hiya"</strong>);
    assert_equal(length, 5, "Should be 5, but was %d", length);
}
]]></c>
                ...we'll get our own helpful message...
<sh><![CDATA[
Running "strlen_test.c"...<strong>
Failure!: strlen_of_hello_should_be_five -> Should be 5, but was 4 at [strlen_test.c] line [6]</strong>
Completed "strlen_test.c": 0 passes, 1 failure, 0 exceptions.
]]></sh>
                Cgreen appends the location of the test failure to
                our error string.
            </p>
            <p>
                Once we have a basic test scaffold up, it's pretty easy to
                add more tests.
                Adding a test of <code>strlen()</code> with an empty string
                for example...
<c><![CDATA[
...<strong>
static void strlen_of_empty_string_should_be_zero() {
    int length = strlen("\0");
    assert_equal(length, 0, "Should be 0, but was %d", length);
}</strong>

TestSuite *<strong>our_tests</strong>() {
    TestSuite *suite = create_test_suite();
    add_test(suite, strlen_of_hello_should_be_five);<strong>
    add_test(suite, strlen_of_empty_string_should_be_zero);</strong>
    return suite;
}
...
]]></c>
            </p>
        </section>
        <section name="fixtures" title="Set up and tear down">
            <p>
                It's common for test suites to have a lot of duplicate code,
                especially when setting up similar tests.
				Take this for example...
<c><![CDATA[
#include "cgreen/cgreen.h"
#include <stdlib.h>
#include <mysql/mysql.h>
#include "person.h"
<strong>
static void create_schema() {
    MYSQL *connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
    mysql_query(connection, "create table people (name, varchar(255) unique)");
    mysql_close(connection);
}

static void drop_schema() {
    MYSQL *connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
    mysql_query(connection, "drop table people");
    mysql_close(connection);
}</strong>

static void can_add_person_to_database() {
    <strong>create_schema();</strong>
    Person *person = create_person();
    set_person_name(person, "Fred");
    save_person(person);
    Person *found = find_person_by_name("Fred");
    assert_string_equal(get_person_name(person), "Fred", NULL);
    <strong>drop_schema();</strong>
}

static void cannot_add_duplicate_person() {
    <strong>create_schema();</strong>
    Person *person = create_person();
    set_person_name(person, "Fred");
    assert_true(save_person(person), NULL);
    Person *duplicate = create_person();
    set_person_name(duplicate, "Fred");
    assert_false(save_person(duplicate), NULL);
    <strong>drop_schema();</strong>
}

TestSuite *person_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, can_add_person_to_database);
    add_test(suite, cannot_add_duplicate_person);
    return suite;
}

int main(int argc, char **argv) {
    return run_test_suite(person_tests(), create_text_reporter());
}
]]></c>
                We have already factored out the duplicate code into it's
                own functions, so things are not so bad...yet.
                What happens though when we get dozens of tests.
                For something as compicated as database ActiveRecord
                functionality, having dozens of tests is very likely.
            </p>
            <p>
                We can get Cgreen to do some of the work for us by
                declaring these methods as <code>setup()</code> and
                <code>teardown()</code> functions in the test suite.
            </p>
            <p>
                Here is the new version...
<c><![CDATA[
...
static void create_schema() { ... }

static void drop_schema() { ... }

static void can_add_person_to_database() {
    Person *person = create_person();
    set_person_name(person, "Fred");
    save_person(person);
    Person *found = find_person_by_name("Fred");
    assert_string_equal(get_person_name(person), "Fred", NULL);
}

static void cannot_add_duplicate_person() {
    Person *person = create_person();
    set_person_name(person, "Fred");
    assert_true(save_person(person), NULL);
    Person *duplicate = create_person();
    set_person_name(duplicate, "Fred");
    assert_false(save_person(duplicate), NULL);
}

TestSuite *person_tests() {
    TestSuite *suite = create_test_suite();<strong>
    setup(suite, create_schema);
    teardown(suite, drop_schema);</strong>
    add_test(suite, can_add_person_to_database);
    add_test(suite, cannot_add_duplicate_person);
    return suite;
}
...
]]></c>
                With this new arrangement Cgreen runs the <code>create_schema()</code>
                function before each test, and the <code>drop_schema()</code>
                function after each test.
            </p>
            <p>
                The reason we try so hard to strip everything out of
                the test functions is that that the test suite acts
                as documentation.
                In our <em>person.h</em> example we can easily see that
                <code>Person</code> has some kind of name property, and
                that this value must be unique.
                For the tests to act like a readable specification we have
                to remove as much mechanical clutter as we can.
            </p>
            <p>
                One detail.
                The <code>teardown()</code> function may not be run if the
                test crashes, causing some test interference.
                This brings us nicely onto the next section...
            </p>
        </section>
        <section name="fork" title="Each test in it's own process">
            <p>
            </p>
        </section>
        <section name="suites" title="Building composite test suites">
        </section>
    </content>
    <internal>
        <link>
            Writing <a href="#writing">Cgreen tests</a>.
        </link>
        <link>
            The <a href="#fixtures">setup() and teardown()</a> fixtures.
        </link>
        <link>
            <a href="#fork">Each test in it's own process</a>.
        </link>
        <link>
            Creating <a href="#suites">composite test suites</a>.
        </link>
    </internal>
    <external>
        <link>
            The <a href="http://sourceforge.net/projects/cgreen">Cgreen SourceForge page</a>.
        </link>
        <link>
            Unit testing was popularised by <a href="http://extremeprogramming.org">eXtreme Programming</a>.
        </link>
    </external>
    <meta>
        <keywords>
        </keywords>
    </meta>
</page>