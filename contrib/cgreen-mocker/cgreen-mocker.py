#!/usr/bin/env python
#-----------------------------------------------------------------
# cgreen-mocker.py
#
# Create Cgreen mocks from extern declarations of functions,
# typically in a header file.
#
# Usage:
#   cgreen-mocker.py <headerfile> { <cpp_directive> }
#
# <headerfile>: file with function declarations that you want
#               to mock
# <cpp_directive>: any 'cpp' directive but most useful is e.g.
#                  "-I <directory>" to ensure cpp finds files.
#
# Simplistically adapted from pycparser example: func_defs.py
#
# Since it uses pycparser it will only handle C functions
# and you will probably need the pycparsers "fake_libc_include"
# to avoid parsing the whole world of libc headers. You can
# make a soft link in your directory to a copy of the pycparser
# source, and cgreen-mocker will pick it up or you can point
# to it using a command line 'cpp_directive' arg.
#
# You can find pycparser at https://github.com/eliben/pycparser
#
# Thanks to @gardenia for the pointer to pycparser!
#
# (C) 2016, Thomas Nilefalk
#
# Using pycparser for printing out all the functions defined in a
# C file.
#
# This is a simple example of traversing the AST generated by
# pycparser. Call it from the root directory of pycparser.
#
# Copyright (C) 2008-2015, Eli Bendersky
# License: BSD
#-----------------------------------------------------------------
from __future__ import print_function
import sys

# This is not required if you've installed pycparser into
# your site-packages/ with setup.py
sys.path.extend(['.', '..'])

from pycparser import c_parser, c_ast, parse_file, c_generator


# A visitor for FuncDef nodes that prints the
# Cgreen mock equivalent of the function
class FuncDefVisitor(c_ast.NodeVisitor):
    def visit_FuncDecl(self, node):
        generator = c_generator.CGenerator()
        print(generator.visit(node), end="")
        print(" { ")
        should_return(node)
        print("mock(%s);" % ", ".join(arg_list(node.args)))
        print("}")
        print()

def arg_list(args):
    if args != None and len(args.params) > 0:
        return [el for el in map(parameter_name_or_box_double, args.params) if el is not None]
    else:
        return []

def parameter_name_or_box_double(node):
    if isdouble_decl(node):
        return "box_double({})".format(node.name)
    else:
        return node.name

def should_return(node):
    generator = c_generator.CGenerator()
    if isdouble_decl(node):
        print("  return unbox_double(", end="")
    elif not isvoid_decl(node):
        print("  return (", end="")
        print(generator.visit(node.type), end="")
        if isinstance(node.type, c_ast.PtrDecl):
            print(" *", end="")
        print(") ", end="")
    else:
        print("  ", end="")

def isvoid_decl(node):
    type = node.type
    return isinstance(type, c_ast.TypeDecl) and type.type.names == ['void']

def isdouble_decl(node):
    type = node.type
    return isinstance(type, c_ast.TypeDecl) and type.type.names == ['double']

def show_func_defs(args):
    # Note that cpp is used. Provide a path to your own cpp or
    # make sure one exists in PATH.
    ast = parse_file(args[0], use_cpp=True,
                     cpp_args=[r'-Ipycparser/utils/fake_libc_include'] + args[1:])

    v = FuncDefVisitor()
    v.visit(ast)

def usage():
    print("""
Usage:
    cgreen-mocker.py <headerfile> { <cpp_directive> }

    <headerfile>:    file with function declarations that you want
                     to mock
    <cpp_directive>: any 'cpp' directive but most useful are e.g.
                     "-I <directory>" to ensure cpp finds files and
                     "-D <define>" to create an inline define""")

if __name__ == "__main__":
    if len(sys.argv) <= 1:
        usage()
        exit(-1)
    show_func_defs(sys.argv[1:])
